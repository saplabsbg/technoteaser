# SAP Техноблъсканица 2019

<link rel="stylesheet" href="../styles/technoteaser.css">
<link rel="stylesheet" href="../styles/footer.css">
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

{::nomarkdown}

<input type="checkbox" id=week1Toggle>
<label for=week1Toggle class="week">
<h2 id=week1>Седмица №1 <span></span></h2>
</label>	
<div>

Играем в телевизионна игра. Разполагаме с 8 еднакви и неразличими на външен вид кутии, във всяка от които има по 2 камъчета. Всяко камъче може да бъде скъпоценно или не. Избираме една кутия и водещият, без да поглежда в нея, изважда едно от камъчетата. То се оказва скъпоценно. Тогава водещият заявява, че имаме точно 50% шанс и второто камъче в тази кутия да е скъпоценно.<br>
Ако знаем, че първоначално броят на скъпоценните камъчета е не по-малък от броя на нескъпоценните, кои от следните твърдения трябва да са верни?<br>
Приемаме, че водещият знае разпределението на камъчетата в кутиите - в колко кутии скъпоценните камъчета са 2, в колко е 1 и в колко са 0. Водещият обаче не знае какви са камъчетата в една конкретна кутия, тъй като самият той не различава кутиите. 

<ul class="answersWithCheckbox">
	<li> Ако поискаме смяна на кутията, ще имаме по-голям шанс следващото изтеглено камъче да е скъпоценно.</li>
	<li> Ако поискаме смяна на кутията, няма да променим шанса си следващото изтеглено камъче да е скъпоценно.</li>
	<li> Ако поискаме смяна на кутията, ще имаме по-малък шанс следващото изтеглено камъче да е скъпоценно.</li>
	<li> Първоначално в играта е имало точно 2 кутии с по две скъпоценни камъчета.</li>
	<li> Първоначално половината кутии са имали по едно скъпоценно и едно нескъпоценно камъче.</li>
	<li> Първоначално в играта е имало равен брой скъпоценни и нескъпоценни камъчета.</li>
	<li> Първоначално броят на кутиите с 2 скъпоценни камъчета е равен на броя на кутиите с 2 нескъпоценни камъчета.</li>
	<li> Водещият се е объркал. Няма как шансът за второ скъпоценно камъче в кутията ни да е точно 50%, тъй като в играта остават нечетен брой камъчета.</li>
</ul>

<div>
	<input type="checkbox" id=solution11><label class="explanationbutton" for=solution11><span>Обяснение</span></label>
	<div class="explanation">
В оригинал задачата е популярна като <a href="https://en.wikibooks.org/wiki/Puzzles/Statistical_puzzles/3_Bags_of_Marbles" target="_blank">3 Bags of Marbles</a>, като най-подвеждащото в случая е да съобразим, че въпреки избора на кутия, реално имаме информация само за едно единствено камъче. Можем да се окажем в ситуацията да сме избрали кутия с две скъпоценни камъчета (нека я наречем печеливша) по два различни начина - като изтеглим първото или като изтеглим второто скъпоценно камъче от нея. От друга страна можем да се окажем в ситуацията да сме избрали непечеливша кутия само по един единствен начин - като сме изтеглили единственото пeчелившо камъче от нея.
<h3 id="week1,solution11,Разпределение">Какво е разпределението на камъчетата?</h3>
Означаваме броя на кутиите с по 1 скъпоценно камъче (т.е. броя на непечелившите кутии) с <b title="Брой кутии с едно скъпоценно камъче">x</b>.<br>
Очевидно имаме поне 1 кутия с 2 скъпоценни камъчета, в противен случай шансът за второ скъпоценно камъче в избраната от нас кутия ще бъде 0%.<br>
1. Предполагаме, че първоначално в играта е имало 1 единствена кутия с 2 скъпоценни камъчета в нея. 
Номерираме всички скъпоценни камъчета с v<sub>i</sub> (valuable) и всички нескъпoценни с n<sub>i</sub> (not valuable)<br> 
<style> 
.box {border-style: solid; border-width: 1px; border-radius: 4px 4px 0px 0px; border-color:grey; margin:5px 5px 5px 5px; padding: 0px 2px 1px 2px; background-color:#f7f7f7;white-space: nowrap; line-height: 150%;}
</style>
<span class="box">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box">v<sub>3</sub>, n<sub>1</sub></span>...<span class="box">v<sub>2+x</sub>, n<sub>x</sub></span>
<br>
По колко начина може да сме стигнали до кутия с извадено скъпоценно камъче?<br>
От печеливша кутия: Изтеглено е v<sub>1</sub> или v<sub>2</sub><br>
От непечеливша кутия:  Изтеглено е v<sub>3</sub> или v<sub>4</sub> ... или v<sub>2+x</sub><br>
Тъй като двете вероятности според водещия са равни, то трябва да имаме точно 2 непечеливши случая и точно 2 кутии с по 1 скъпоценно камъче, т.е. <b title="Брой кутии с едно скъпоценно камъче">x</b>=2<br>
Получаваме общо 4 скъпоценни камъчета и 14 нескъпоценни. Но по условие скъпоценните са поне колкото нескъпоценните, затова 1 кутия с 2 скъпоценни камъчета не е възможно разпределение.<br> 
2. Ако предположим, че имаме 2 кутии с по 2 скъоценни камъчета, то <br> 
<span class="box">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box">v<sub>3</sub>, v<sub>4</sub></span> 
<span class="box">v<sub>5</sub>, n<sub>1</sub></span> 
...
<span class="box">v<sub>4+x</sub>, n<sub>x</sub></span>
<br>
Имаме 4 възможности за първо избрано камъче от печеливша кутия: v<sub>1</sub>,v<sub>2</sub>,v<sub>3</sub>,v<sub>4</sub><br>
За да имаме 4 възможности от непечеливша кутия, трябва да имаме 4 кутии с по 1 скъпоценно камъче (<b title="Брой кутии с едно скъпоценно камъче">x</b>=4)<br>
Получаваме **2 кутии с по 2 скъпоценни камъчета, 4 кутии с по 1 скъпоценнно камъче** и остават **2 кутии с 2 нескъпоценни камъчета**.<br>
3. Нека предположим, че имаме 3 кутии с по 2 скъпоценни камъчета. <br>
По аналогичен начим виждаме, че трябва да имаме <b title="Брой кутии с едно скъпоценно камъче">x</b>=6 кутии с по 1 скъпоценно камъче, но получаваме общо 3+6=9 кутии, а по условие имаме само 8. Същите разсъждения са валидни за всяко разпределение с повече от 3 печеливши кутии.<br>
Получихме единствено възможно разпределение на камъчетата, откъдето следват няколко верни твърдения:<br>
<nobr><span class="box" style="background-color:#eafff1">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box" style="background-color:#eafff1">v<sub>3</sub>, v<sub>4</sub></span></nobr>
<nobr><span class="box" style="background-color:#ffffed">v<sub>5</sub>, n<sub>1</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>6</sub>, n<sub>2</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>7</sub>, n<sub>3</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>8</sub>, n<sub>4</sub></span></nobr>
<nobr><span class="box" style="background-color:#f2e6e6">n<sub>5</sub>, n<sub>6</sub></span>
<span class="box" style="background-color:#f2e6e6">n<sub>7</sub>, n<sub>8</sub></span></nobr><br>
✔ Първоначално в играта е имало точно 2 кутии с по два скъпоценни камъчета. <br>
✔ Първоначално половината кутии са имали по едно скъпоценно и едно нескъпоценно камъче. <br>
✔ Първоначално в играта е имало равен брой скъпоценни и нескъпоценни камъчета. <br>
✔ Първоначално броят на кутиите с 2 скъпоценни камъчета е равен на броя на кутиите с 2 нескъпоценни камъчета. <br>
<h3 id="week1,solution11,Вероятност">Защо остават нечетен брой камъчета и 50% вероятност за второ скъпоценно камъче?</h3>
След като сме изтеглили и видели едно от камъчетата, не всички останали камъчета участват с еднакво тегло в изчисляването на вероятността за това какво е второто камъче в кутия ни. Например броят на кутиите с по 2 нескъпоценни камъчета и съответно камъчетата от n<sub>5</sub> до n<sub>8</sub> не влияят по никакъв начин на тази вероятност.<br>
Друг поглед върху ситуацията е, че с второто камъче определяме типа кутия. В случая сме имали 50% шанс да изберем първото скъпоценно камъче и текущ шанс 50% за второ скъпоценно камъче, т.е. обща вероятност от 50%∗50%=25% за кутия с 2 скъпоценни камъчета.
<h3 id="week1,solution11,Шанс">Как променяме шанса си при смяна на кутията?</h3>
От 4-те непечеливши комбинации (камъчета от v<sub>5</sub> до v<sub>8</sub>), когато в кутията ни има второ нескъпоценно камъче, при премахването на нашата кутия в играта остават равен брой скъпоценни и нескъпоценни камъчета и ⇒ 50% шанс за това второто изтеглено камъче да е скъпоценно.<br>
От 4-те печеливши комбинации обаче (камъчета от v<sub>1</sub> до v<sub>4</sub>), когато в кутията ни има второ скъпоценно камъче, при премахването на нашата кутия в играта остават 6 скъпоценни и 8 нескъпоценни камъчета, т.е. имаме шанс за успех 6/14≈42.857%<br> 
Сумарно при смяна на кутиите шансът ни за второ скъпоценно камъче ще бъде по-малък ( ≈ 46.4%).<br>
Получихме:<br>
<ul class="answersWithCheckbox">
	<li class="notCorrectAnswer"> Ако поискаме смяна на кутията, ще имаме по-голям шанс следващото изтеглено камъче да е скъпоценно.</li>
	<li class="notCorrectAnswer"> Ако поискаме смяна на кутията, няма да променим шанса си следващото изтеглено камъче да е скъпоценно.</li>
	<li class="correctAnswer"> Ако поискаме смяна на кутията, ще имаме по-малък шанс следващото изтеглено камъче да е скъпоценно.</li>
	<li class="correctAnswer"> Първоначално в играта е имало точно 2 кутии с по две скъпоценни камъчета.</li>
	<li class="correctAnswer"> Първоначално половината кутии са имали по едно скъпоценно и едно нескъпоценно камъче.</li>
	<li class="correctAnswer"> Първоначално в играта е имало равен брой скъпоценни и нескъпоценни камъчета.</li>
	<li class="correctAnswer"> Първоначално броят на кутиите с 2 скъпоценни камъчета е равен на броя на кутиите с 2 нескъпоценни камъчета.</li>
	<li class="notCorrectAnswer"> Водещият се е объркал. Няма как шансът за второ скъпоценно камъче в кутията ни да е точно 50%, тъй като в играта остават нечетен брой камъчета.</li>
</ul>
<hr>
<h3 id="week1,solution11,Проверка">Проверка на решението</h3>
Тъй като задачата е наистина заблуждаваща, с което е и станала известна, как можем да проверим, че решението е вярно? Все пак теорията на вероятностите е точна наука и един конкретен изход от една конкретна ситуация трябва да се сбъдва с една единствена вероятност, т.е. различни интерпретации са невъзможни.<br>
Нека вземем предложеното решение за кутии и разиграем достатъчно много на брой пъти ситуацията (например 10 000 пъти), за да придобием представа за вероятността. За целта ще напишем програма, която дословно следва условието на задачата, т.е.
1. На случаен принцип избираме една от осемте налични кутии
2. На случаен принцип избираме едно камъче от вече избраната кутия
3. Ако камъчето е нескъпоценно, игнорираме ситуацията, защото не отговаря на условието (продължаваме нататък без да правим нищо)
4. Ако камъчето е скъпоценно, преброяваме ситуацията като печеливша или не спрямо второто камъче в избраната кутия
Примерна програма на Java, преброяваща 10 000 валидни ситуации:
{:/}

```java
int[][] setup = { {1,1}, {1,1}, {1,0}, {1,0}, {1,0}, {1,0} }; //,{0,0},{0,0}
Random r = new Random();
int successfullPositions = 0;
int unsuccessfullPositions = 0;
for(int i=0; i<10000; i++) {
	int boxIndex = r.nextInt(setup.length);
	int[] box = setup[boxIndex];
	int firstMarbleIndex = r.nextInt(2); 
	int marble = box[firstMarbleIndex];
	if (marble != 1) {
		i--;
		continue;
	}
	int secondMarbleIndex = (firstMarbleIndex+1)%2;
	if (box[secondMarbleIndex] == 1) {
		successfullPositions++;
	} else {
		unsuccessfullPositions++;
	}
}
System.out.println("successful:" + successfullPositions + "; unsuccessful:" + unsuccessfullPositions);
```

{::nomarkdown}
Единственото отклонение от оригиналната ситуация е премахването на двете кутии с по 2 нескъпоценни камъчета в тях, понеже те добавят само неефективност в изпълнението, а програмата би връщала същия резултат и без тях. Примерен резултат:
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:5010; unsuccessful:4990</div>
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:4981; unsuccessful:5019</div>
<br>
Изпълнение на програмата при равен брой кутии с по 2 и с по 1 скъпоценно камъче също показва достатъчно ясно два пъти повече печеливши ситуации спрямо непечелившите.
{:/}

```java
int[][] setup = { {1,1}, {1,1}, {1,1}, {1,1}, {1,0}, {1,0}, {1,0}, {1,0} }; 
```

{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:6572; unsuccessful:3428</div>		

<br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week1/BagsOfMarbles.java" target="_blank">Примерен Java код</a>
	</div> 
</div>
{:/}


<hr>

Колко са естествените числа (цели положителни числа ≥ 1), които са равни на произведението от цифрите си?<br>
Ако са безкрайно много, отговорете с английската буква i (от infinitely many) 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution12><label class="explanationbutton" for=solution12><span>Обяснение</span></label>
	<div class="explanation">
Разглеждаме естествените числа, които имат k цифри (k≥1) и първа цифра d<sub>1</sub>.<br>
Произведението от цифрите e най-голямо, когато всяка цифра след d<sub>1</sub> е 9, т.е. то е ≤ d<sub>1</sub>∗9<sup>k-1</sup><br>
Самото число е най-малко, когато цифрите след d<sub>1</sub> са 0, т.е. числото е  ≥ d<sub>1</sub>∗10<sup>k-1</sup>.<br>
d<sub>1</sub>∗9<sup>k-1</sup> = d<sub>1</sub>∗10<sup>k-1</sup> само при к=1<br>
⇒ едноцифрените числа от 1 до 9 (<b>общо 9 на брой</b>) са единствените естествени числа с това свойство.	
	</div> 
</div>
{:/}

<hr>

Ученик неволно откъснал един лист от учебника си по математика. След това пресметнал сумата от номерата на останалите страници в учебника и получил 2019 +/- 1 (2018, 2019 или 2020, за да бъдем по-точни).<br>
Колко страници е имал първоначално учебникът?<br>
Приемаме, че само последната страница в учебника може да бъде празна и неномерирана.<br>
Ако първоначалният брой страници не може да се определи еднозначно, моля отговорете с английската буква u (от undefined). 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution13><label class=explanationbutton for=solution13><span>Обяснение</span></label>
	<div class="explanation">
Нека учебникът има оригинално <i title="Оригинален брой страници на учебника"><b>X</b></i> страници с обща сума на страниците <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>, сума на страниците без откъснатия лист <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i> и сума на страниците на откъснатия лист <i title="Сума на страниците на откъснатия лист"><b>l</b></i>.<br>
Знаем, че <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>+<i title="Сума на страниците на откъснатия лист"><b>l</b></i>=<i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>, <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018, 2019 или 2020<br>
Какви предположения можем да направим за <i title="Сума на страниците на откъснатия лист"><b>l</b></i>?<br>
Ако сме откъснали последния лист, а последната страница е била празна, то <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=<i title="Оригинален брой страници на учебника"><b>X</b></i>.<br>
В противен случай <i title="Сума на страниците на откъснатия лист"><b>l</b></i> е сума на 2 последователни числа. Всеки лист съдържа нечетно число първа по ред страница и четно число втора по ред страница (с 1 по-голяма от първата). <i title="Сума на страниците на откъснатия лист"><b>l</b></i> e сума на нечетно и четно число ⇒ <i title="Сума на страниците на откъснатия лист"><b>l</b></i> е нечетно число.<br><br>
Колко най-малко страници е имал учебникът?<br>
Нека разгледаме учебник, от който не сме скъсали лист, с X<sub>0</sub> страници и сума на страниците 2018.<br>
Номерата на страниците започват от 1 и завършват с X<sub>0</sub>, образувайки аритметична прогресия със сума = X<sub>0</sub>(X<sub>0</sub>+1)/2=2018, т.е.<nobr> X<sub>0</sub><sup>2</sup>+X<sub>0</sub>–2∗2018=0</nobr><br>
Положителният корен на квадратното уравнение e \( X_0 = \dfrac{-1+\sqrt{1+4*2*2018}}{2} \), <nobr>X<sub>0</sub> ≈ 63,03</nobr><br>
<!-- (-1+√<span style="text-decoration: overline;">1+4∗2∗2018</span>)/2= 126/2 -->
Нашият учебник е с един лист повече и следователно <i title="Оригинален брой страници на учебника"><b>X</b></i>≥64<br>
1. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=64 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=64∗65/2=2080 страници<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2018=62 страници, което е четно число и не може да е сума на страниците от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2019 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2019=61 страници = 30+31, но първата страница е четна и следователно също не може да е първа страница от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2020=60 страници и също не могат да са от един лист.<br>
=> Учебникът няма как да е имал 64 страници.<br>
2. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=65 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=65∗66/2=2145<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2018=127=63+64. Това е предпоследният лист от учебник с 65 страници и сума на страниците без този лист <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 => <i title="Оригинален брой страници на учебника"><b>X</b></i>=65 e възможен отговор.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2019 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2019=126 и не може да бъде сума на страниците от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2020=125=62+63, които отново не са страници на един лист.
3. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=66 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=66∗67/2=2211, но дори за най-голямото <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=191=95+96, а учебникът в този случай има само 66 страници.<br> Същите съображения са валидни и за <i title="Оригинален брой страници на учебника"><b>X</b></i>>66.<br>

Получихме единствено решение при учебник с <b>65</b> стр. <br>
Тъй като и тук има различни интерпретации за това дали трябва да преброим последната неномерирана страница или не, приемаме и отговор <b>66</b> за верен!	
	</div> 
</div>
</div>

<input type="checkbox" id=week2Toggle>
<label for=week2Toggle class="week">
<h2 id=week2>Седмица №2 <span></span></h2>
</label>	
<div>
	
{:/}

Миналата година (т.е. беше ден от 2018 г.) разговарях с Марто за неговия рожден ден. Той ми каза следното:

> Онзи ден (денят преди вчера) бях само на 14 години, но следващата година ставам на 17 години.

Каква е рождената дата на Марто?<br>
Приемаме, че на рождената си дата човек (през целия ден) е с 1 година по-възрастен, отколкото е бил на предходния ден.<br>
Моля, отговорете във формата dd.mm.yyyy (например 01.03.2019 за първи март 2019 г.) или с английската буква u (от undefined), ако рождената дата не може да бъде определена еднозначно. 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution21><label for=solution21 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Разговорът е проведен на 1 януари 2018 г.<br>
Марто има рожден ден на 31 декември.<br>
На 30.12.2017 (2 дена преди деня, в който се е провел разговора) е бил на 14.<br>
На 31.12.2017 е станал на 15.<br>
На 01.01.2018 (в деня на разговора) Марто е на 15 и през същата 2018-та година ще стане на 16.<br>
На 31.12.2019 (следващата година спрямо разговора) ще стане на 17.<br>
⇒ Марто е роден на <b>31.12.2002</b>
	</div> 
</div>
{:/}

<hr>

Катя е в първи клас и е добра по математика.<br>
Тя е написала следното изречение, заменяйки някои числа в него със символа _ (долна черта):

> В това изречение<br>
> цифрата 1 се среща _ път(и),<br>
> цифрата 2 се среща _ път(и),<br>
> цифрата 3 се среща _ път(и),<br>
> цифрата 4 се среща _ път(и),<br>
> цифрата 5 се среща _ път(и),<br>
> цифрата 6 се среща _ път(и),<br>
> цифрата 7 се среща _ път(и),<br>
> цифрата 8 се среща _ път(и) и<br>
> цифрата 9 се среща _ път(и).<br>

По колко различни начина Катя е можела да напише това изречение, така че то да е вярно, ако тя може да смята до 9 включително и затова в изречението има само едноцифрени числа? 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution22><label for=solution22 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Тази логическа задача в оригинал съдържа изречение с всички цифри (от 0 до 9 вкл.), без ограничение за големината на числата и е на американския математик Raphael M. Robinson.<br>
Далеч по-лесно е да се намери едно конкретно решение, отколкото да се намерят и преброят всички решения.<br>
Тъй като проверката на всички възможности е с експоненциална сложност спрямо броя на неизестните числа, за програмно решение с приемливо бързодействие е важно да се изследват възможнoтo минимално и максимално участие на всяка цифра в изречението, което, заедно с примерно решение на Java може да видите в обяснението на следващата задача.
С така зададеното условие задачата има едно единствено решения и то е:<br>
[1→6, 2→3, 3→2, 4→1, 5→1, 6→2, 7→1, 8→1, 9→1]<br>

{:/}

> В това изречение<br>
цифрата 1 се среща 6 път(и),<br>
цифрата 2 се среща 3 път(и),<br>
цифрата 3 се среща 2 път(и),<br>
цифрата 4 се среща 1 път(и),<br>
цифрата 5 се среща 1 път(и),<br>
цифрата 6 се среща 2 път(и),<br>
цифрата 7 се среща 1 път(и),<br>
цифрата 8 се среща 1 път(и) и<br>
цифрата 9 се среща 1 път(и).

{::nomarkdown}

Другите две възможности за вярно изречение съдържат двуцифрени числа, но пък и можем да ги класифицираме като тривиални:<br>
<font color="grey">
[1→10, 2→1, 3→1, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1]<br>
[1→11, 2→1, 3→1, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1]
</font>
	</div> 
</div>
{:/}

<hr>

Жорко е по-голям от Катя и е написал следното по-сложно изречение:

> В това изречение<br>
 цифрата 1 се среща _ път(и),<br>
 цифрата 2 се среща _ път(и),<br>
 цифрата 3 се среща _ път(и),<br>
 цифрата 4 се среща _ път(и),<br>
 цифрата 5 се среща _ път(и),<br>
 цифрата 6 се среща _ път(и),<br>
 цифрата 7 се среща _ път(и),<br>
 цифрата 8 се среща _ път(и),<br>
 цифрата 9 се среща _ път(и) и<br>
 числото 10 се среща _ път(и).

По колко различни начина Жорко е можел да напише това изречение, така че то да е вярно, ако той може да смята с произволно големи цели числа?<br>
Приемаме, че ако изречението съдържа твърдението
> числото 10 се среща 101 път(и)

то за тази част от изречението трябва да преброим 2 срещания на цифрата 0, 3 срещания на цифрата 1 и 2 срещания на числото 10.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution23><label for=solution23 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
От нескритите числа виждаме, че цифрите 0 и 1 се срещат поне по 2 пъти, а всички останали цифри и числото 10 се срещат поне по веднъж.<br>
Нека анализираме колко цифри <b title="Брой цифри в изречението">N</b> може да има в изречението?<br>
Нескритите цифри са 12. За всяко нескрито число (общо 11) добавяме поне по още 1 цифра за съответния брой срещания, т.е. <b title="Брой цифри в изречението">N</b>≥12+11=23.<br>
Ако допуснем, че има поне 2 числa d<sub>1</sub> и d<sub>2</sub>, които се срещат 10 или повече пъти, то <b title="Брой цифри в изречението">N</b>≥25, а d<sub>1</sub> и d<sub>2</sub> се срещат поне по 8 пъти всяко измежду скритите числа, обозначени с _. Понеже имаме 11 непоказани числа, в които трябва да преброим поне по 8 пъти  d<sub>1</sub> и d<sub>2</sub>, стигаме до нуждата от 5 двуцифрени непоказани числа, които изискват поне 5∗10=50 цифри в изречението и нуждата да преброим  50-12=38 цифри в непоказаните числа, което от своя страна изисква четирицифрено число там. Тъй като не можем да достигнем до крайно число брой цифри, предположението ни за второ двуцифрено число е грешно. Същото важи и за трицифрени и по-големи числа. <br>
Получихме 23≤<b title="Брой цифри в изречението">N</b>≤24 (можем да имаме 0 или 1 скрито двуцифрено число).<br>
Нека цифрата 0 се среща i<sub>0</sub> пъти, цифрата 1 се среща i<sub>1</sub> пъти, ... и числото 10 съответно i<sub>10</sub> пъти.
<ol>
	<li>Колко най-много пъти може да срещем цифрата 0? (i<sub>1</sub>≤?)<br>
Тъй като всяко число се среща поне по веднъж, в скритите числа може да срещнем 0 само от двуцифрено число, т.е. най-много веднъж и 2 ≤ i<sub>0</sub> ≤ 3. </li>
	<li>i<sub>1</sub> ≤ ?<br>
Цифрaтa 1 се среща точно 2 пъти измежду вече показаните числа. Ако едно се среща 11 пъти и всички други числа (без 0) се срещат точно по веднъж, получаваме 13≠11 ⇒ i<sub>1</sub> ≤ 12.</li>
	<li>i<sub>2</sub> ≤ ?<br>
Ако i<sub>2</sub>=6, то 5 от тези срещания ще са в непоказаните числа и поне 3 от тези срещания (без тези за 0 и 1) ще изискват повторение на съответното число в изречението отново в непоказаната част. Например:
<small><table>
<tr><td>Показани</td><td> </td><td>Непоказани</td></tr>
<tr><td align=center style="color:green">0</td><td>→&nbsp;</td><td style="color:green">2<sub style="color:black">2</sub></td></tr>
<tr><td align=center style="color:green">1</td><td>→&nbsp;</td><td style="color:green">2<sub style="color:black">3</sub></td></tr>
<tr><td align=center >2<sub style="color:black">1</sub></td><td>→&nbsp;</td><td style="color:DarkBlue">6</td></tr>
<tr><td align=center style="color:brown">3</td><td>→&nbsp;</td><td style="color:brown">2<sub style="color:black">4</sub></td></tr>
<tr><td align=center style="color:red">4</td><td>→&nbsp;</td><td style="color:red">2<sub style="color:black">5</sub></td></tr>
<tr><td align=center >5</td><td>→&nbsp;</td><td style="color:brown">3</td></tr>
<tr><td align=center style="color:DarkBlue">6</td><td>→&nbsp;</td><td style="color:DarkBlue">2<sub style="color:black">6</sub></td></tr>
<tr><td align=center >7</td><td>→&nbsp;</td><td style="color:red">4</td></tr>
<tr><td align=center >8</td><td>→&nbsp;</td><td>_</td></tr>
<tr><td align=center >9</td><td>→&nbsp;</td><td>_</td></tr>
<tr><td align=center style="color:green">10</td><td>→&nbsp;</td><td>_</td></tr>
<tr><td> </td><td> </td><td> - - - </td></tr>
<tr><td> </td><td> </td><td>Поне 23+3 цифри &gt; 24</td></tr>
</table></small>
Сумата на непоказаните числа обаче трябва да е &lt; <b title="Брой цифри в изречението">N</b>, понеже броим и числото 10 ⇒ i<sub>2</sub>≤5.<br>
Аналогично i<sub>3</sub>≤5, i<sub>4</sub>≤5, i<sub>5</sub>≤5, i<sub>6</sub>≤5, i<sub>7</sub>≤5, i<sub>8</sub>≤5 и i<sub>9</sub>≤5. Въпреки че тук можем да бъдем и доста по-стриктни в анализа, тези ограничения са достатъчно добри за тази версия на задачата.</li>
<li>Вече знаем, че имаме най-много 1 двуцифрено число измежду непоказаните ⇒ 1≤i<sub>10</sub>≤2.</li>
</ol>
{:/}

```java
int resultCount = 0;
for (int i0 = 2; i0 <= 3; i0++)
for (int i1 = 2; i1 <= 12; i1++)
for (int i2 = 1; i2 <= 5; i2++)
for (int i3 = 1; i3 <= 5; i3++)
for (int i4 = 1; i4 <= 5; i4++)
for (int i5 = 1; i5 <= 5; i5++)
for (int i6 = 1; i6 <= 5; i6++)
for (int i7 = 1; i7 <= 5; i7++)
for (int i8 = 1; i8 <= 5; i8++)
for (int i9 = 1; i9 <= 5; i9++)
for (int i10 = 1; i10 <= 2; i10++) {
    int[] currentDigits = new int[] 
	    {i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10};
    int[] actualCounts = new int[] 
	    {2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    for (int i = 0; i <= 10; i++) {
	int num = currentDigits[i];
	if (num < 10) {
	    actualCounts[num] = actualCounts[num] + 1;
	} else {
	    int firstDigit = (num / 10);
	    int secondDigit = (num % 10);
	    actualCounts[firstDigit] = actualCounts[firstDigit] + 1;
	    actualCounts[secondDigit] = actualCounts[secondDigit] + 1;
	    if (num == 10) {
		actualCounts[10] = actualCounts[10] + 1;
	    }
	}
    }
    if (Arrays.equals(currentDigits, actualCounts)) {
	resultCount++;
	System.out.println(IntStream.range(0, 11)
		.mapToObj(n -> n + "→" + currentDigits[n])
		.collect(Collectors.joining(
			", ",
			"Решение №" + resultCount + ": [", 
			"]")));
    }
}
```

{::nomarkdown}

Получаваме следните 3 решения:<br>
Решение №1: [0→2, 1→8, 2→3, 3→3, 4→1, 5→1, 6→1, 7→1, 8→2, 9→1, 10→1]<br>
Решение №2: [0→2, 1→8, 2→4, 3→1, 4→2, 5→1, 6→1, 7→1, 8→2, 9→1, 10→1]<br>
Решение №3: [0→2, 1→11, 2→3, 3→2, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1, 10→1]<br>
<br>
И след толкова сметки, които могат да оставят погрешно впечатление, че задачата е трудна, трябва да уточним, че въпросният анализ може да се замени (в този случай доста успешно) с по-елемнтарна оценка на допустимите стойности на числата в изречението и по-неефективно решение, което би било напълно достатъчно за намиране на верния отговор.

<br><br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week2/SelfReferencingSentence.java" target="_blank">Примерен Java код</a>
	</div> 
</div>
</div>

<input type="checkbox" id=week3Toggle>
<label for=week3Toggle class="week">
<h2 id=week3>Седмица №3 <span></span></h2>
</label>	
<div>
	
{:/}

Принц посещава далечен остров, на който живеят две племена. Хората от първото племе винаги казват истината, а хората от второто племе винаги лъжат. Принцът присъства като зрител на игрите по случай новата 1823 година, на които хора от двете племена играят своя общ островитянски танц. Играта е по двойки, като от време на време някои хора сменят своя партньор, някои хора влизат, а други излизат от играта. След игрите принцът попитал всеки танцувал по отделно, с колко хора, казващи истината, е играл, като записвал това число в своя тефтер. Когато приключил, принцът с учудване установил, че е получавал все различни отговори, намирайки в тефтера си числата от 0 до 1822 точно по веднъж.<br>
Колко хора, казващи истината, са взели участие в игрите?<br>
Приемаме, че всички на острова се познават помежду си и знаят кой от кое племе е.<br>
Отговорете с английската буква u (от undefined), ако информацията е недостатъчна, за да се отговори еднозначно.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution31><label for=solution31 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Знаем, че в игрите са взели участие 1823 души, като всеки е отговорил с едно от числата между 0 и 1822 и никой друг не е отговорил със същото число. Нека<br> P<sub>1822</sub> e човекът, отговорил с 1822,<br>
P<sub>1821</sub> e човекът, отговорил с 1821,<br>
... <br>
P<sub>1</sub> e човекът, отговорил с 1 и <br>
P<sub>0</sub> e човекът, отговорил с 0<br>
Може ли P<sub>1822</sub> да е казал истината (и следователно винаги да казва истината)?<br>
Ако допуснем, че P<sub>1822</sub> казва истината, то тогава  P<sub>1822</sub> трябва да е играл с всички останали 1822 участници и те да казват истината. Това означава, че P<sub>1822</sub> е играл и с P<sub>0</sub> и P<sub>0</sub> казва истината. Но P<sub>0</sub> твърди, че не е играл с никой, който казва истината, което е в 
противоречие с допускането. Следователно P<sub>1822</sub> не може да е казал истината и е от хората, които винаги лъжат.<br>
Може ли P<sub>1821</sub> да казва истината?<br>
Ако допуснем, че P<sub>1821</sub> казва истината, знаейки че P<sub>1822</sub> лъже, следва, че P<sub>1821</sub> е играл с всички останали и те казват истината. Отново имаме същия проблем с P<sub>0</sub>, който е играл с P<sub>1821</sub> и едновременно казва истината, и е играл с 0 хора, казващи истината, което е противоречие с допускането, откъдето следва, че P<sub>1821</sub> лъже.<br>
Аналогично можем да заключим, че всички хора от P<sub>1820</sub> до P<sub>1</sub> включително лъжат.<br>
Какво означава това за P<sub>0</sub>?<br>
Тъй като всички останали лъжат, P<sub>0</sub> няма как да е играл с някой, който казва истината и следователно трябва да казва истината.<br>
<b>Получаваме 1 човек, който казва истината</b> и 1822<sup>-ма</sup>, които лъжат.
	</div> 
</div>
{:/}

<hr>

Колко естествени числа имат свойството сумата от цифрите и произведението от цифрите им да са равни?<br>
Ако са безкрайно много, отговорете с английската буква i (infinitely many).<br>
Приемаме, че сумата, както и произведението от цифрите на едноцифрено число са равни на самото число.

{::nomarkdown}

<div>
	<input type="checkbox" id=solution32><label for=solution32 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Нека вземем произволно многоцифрено естествено число, за което произведението от цифрите е по-голямо от сумата на цифрите му (примерно 222). От такова число можем да конструираме друго, като добавим толкова единици, колкото е разликата между произведението и сумата на цифрите (222→22211).<br>
Тъй като има безкрайно много естествени числа, за които произведението от цифрите е по-голямо от сумата на цифрите (примерно число, съставено само от цифрата 2, където тя се среща повече от 2 пъти), то има и безкрайно много съпоставими числа, за които произведението от цифрите = сумата на цифрите.<br>
Получаваме верен отговор <b>i</b> (безкрайно много).
	</div> 
</div>
{:/}

<hr>

Разполагаме с цифрите от 1 до 9, подредени във възходящ ред (всяка цифра присъства точно един път), както и с аритметичните операции събиране (+), изваждане (-), умножение (∗) и деление (/).<br>
Между всеки две съседни цифри имаме право да поставим най-много една от тези операции, като всяка операция можем да ползваме произволен брой пъти. Съседни цифри, между които не поставим операция, участват в израза като многоцифрено число.<br>
Колко различни аритметични израза, равни на 465, можем да създадем по този начин?<br>
Приемаме, че важат стандартните приоритети на операциите (умножението и делението са с по-висок приоритет от събирането и изваждането), операциите са ляво асоциативни (т.е. операции с един и същи приоритет се изпълняват от ляво надясно, например 12/3/4=1) и не можем да използваме скоби за смяна на така дефинираната последователност на изчисленията.


{::nomarkdown}
<div>
	<input type="checkbox" id=solution33><label for=solution33 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

<a href="https://en.wikipedia.org/wiki/Brute-force_search" target=_blank>Brute-force</a> подход за решение на задачата изисква генерирането и проверката на всички възможни изрази. Тъй като имаме 4 аритметични операции плюс опцията да пропуснем такава, т.е. можем да считаме, че имаме 5 възможни операции, които трябва да поставим между всеки две съседни цифри (т.е. на 8 места) получаваме 5<sup>8</sup>=390625 израза, които далеч не са много. <br>

Изчисляването на аритметичен израз в Java, като спазваме приоритетите на операциите, за разлика от други езици изисква писането на немалко код. От JDK1.6 обаче можем да ползваме вградения JavaScript engine, a JavaScript-a е доста по-подходящ език в подобни ситуации, при които добавената неефективност от употребата му е приемлива.<br>
{:/}

```java
final String[] OPERATIONS = {"*", "+", "-", "/", ""}; //allow lexicographic order of found expressions
final int[] INPUT = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9};

ScriptEngineManager factory = new ScriptEngineManager();
// create a JavaScript engine
ScriptEngine engine = factory.getEngineByName("JavaScript");

int count = 0;

for (int op1 = 0; op1 < OPERATIONS.length; op1++) 
for (int op2 = 0; op2 < OPERATIONS.length; op2++) 
for (int op3 = 0; op3 < OPERATIONS.length; op3++) 
for (int op4 = 0; op4 < OPERATIONS.length; op4++) 
for (int op5 = 0; op5 < OPERATIONS.length; op5++) 
for (int op6 = 0; op6 < OPERATIONS.length; op6++) 
for (int op7 = 0; op7 < OPERATIONS.length; op7++) 
for (int op8 = 0; op8 < OPERATIONS.length; op8++) {
	String expression = INPUT[0] + OPERATIONS[op1] + INPUT[1] + 
			OPERATIONS[op2] + INPUT[2] +
			OPERATIONS[op3] + INPUT[3] +
			OPERATIONS[op4] + INPUT[4] +
			OPERATIONS[op5] + INPUT[5] +
			OPERATIONS[op6] + INPUT[6] +
			OPERATIONS[op7] + INPUT[7] +
			OPERATIONS[op8] + INPUT[8];
	boolean expressionEvaluationResult = (boolean) engine.eval(expression + " === 465");
	if (expressionEvaluationResult) {
		count++;
		System.out.println(count + ": " + expression + "=" + 465);
	}				
}

```

1. 1∗2∗3∗4∗5+6∗7∗8+9=465
2. 1∗2∗3∗4+56∗7/8∗9=465
3. 1∗2+3-4+5+6∗78-9=465
4. 1∗2+3-4+56∗7+8∗9=465
5. 1∗2-3+456-7+8+9=465
6. 1∗23∗4∗5-67+8∗9=465
7. 1+2∗3+4-5+6∗78-9=465
8. 1+2+3∗45+6∗7∗8-9=465
9. 1+2-3∗4-5∗6+7∗8∗9=465
10. 1+2-3-45+6+7∗8∗9=465
11. 1+2-3/4∗56+7∗8∗9=465
12. 1+23∗4∗5-6-7+8+9=465
13. 1-2∗3-4-5∗6+7∗8∗9=465
14. 1-2∗34+5+67∗8-9=465
15. 1-2+3∗4-5+6∗78-9=465
16. 1-2-3∗4+567-89=465
17. 1-2/3+456+78/9=465 (минава през безкрайна периодична дроб)
18. 1/2∗34-56+7∗8∗9=465
19. 12∗3+45/6∗7∗8+9=465
20. 12∗34+5+6∗78/9=465
21. 12∗34-5∗6+78+9=465
22. 12+3∗4+56∗7/8∗9=465
23. 12+3+456-7-8+9=465
24. 12+3-4-5+6∗78-9=465
25. 12/3/4+5+6∗78-9=465
26. 12/3/4+56∗7+8∗9=465
27. 123∗4-5+67-89=465

{::nomarkdown}

<br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week3/ExpressionsWithoutBracketsRecursive.java" target="_blank">Примерен Java код за рекурсивно решение</a>
<br>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week3/ExpressionsWithoutBracketsIterative.java" target="_blank">Примерен Java код за итеративно решение</a>
	</div> 
</div>
</div>

<input type="checkbox" id=week4Toggle>
<label for=week4Toggle class="week">
<h2 id=week4>Седмица №4 <span></span></h2>
</label>	
<div>

{:/}

Пламен харесва Ани, но Ани харесва Георги.<br>
Пламен е обвързан, а Георги не е.<br>
Можем ли да твърдим със сигурност, че в компанията на Пламен, Ани и Георги (без участието на други хора) обвързан човек харесва необвързан човек?<br>
Приемаме, че човек може да бъде или обвързан, или необвързан.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution41><label for=solution41 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Нека запишем връзките в компанията под формата на мини граф.<br>
<table cellspacing="0" cellpadding="1" style="border: none; margin:0; padding:0; border-spacing:0; border-collapse: collapse;border-spacing: 0; line-height: 0.9;">
<tr><td>Пламен</td><td width="35px" align=center>→</td><td align=center>Ани</td><td width="35px" align=center>→</td><td>Георги, или</td></tr>
<tr><td>Обвързан</td><td width="35px" align=center>→</td><td align=center>?</td><td width="35px" align=center>→</td><td>Необвързан</td></tr>
</table><br>

<ol>
<li>Ако Ани е необвързана, то тогава от факта, че Пламен харесва Ани следва, че обвързан харесва необвързан.</li>
<li>Ако Ани е обвързана, то тогава от факта, че Ани харесва Георги отново следва, че обвързан харесва необвързан.</li>
</ol>

Тъй като други възможности за обвързаността на Ани няма, следва, че <b>твърдението е вярно</b>, въпреки че не можем да кажем конкретно за кои двама души е валидно то.

	</div> 
</div>
<hr>

Колко са естествените числа n, за които n<sup>2</sup> + 2019 е точен квадрат?

<div>
	<input type="checkbox" id=solution42><label for=solution42 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

Нека n<sup>2</sup>+2019=x<sup>2</sup>, където x също е естествено число. Тогава<br>
x<sup>2</sup> - n<sup>2</sup> = 2019<br>
(x - n)(x + n) = 2019<br>
По колко начина можем да представим 2019 като произведение на 2 естествени числа?<br>
Разлагаме 2019 на прости множители (2019=3∗673) и получаваме следните случаи:<br>
{:/}
1. x - n = 3, x + n = 673, откъдето получаваме x = 338, n = 335
2. x - n = 1, x + n = 2019, откъдето получаваме  x = 1010 , n = 1009

{::nomarkdown}
Тъй като (x - n) &lt; (x + n) други случаи (и съответно решения) в естествени числа няма.<br>
⇒ съществуват <b>2 числа</b>, отговарящи на условието.

<h3 id="week4,solution42,Програма">Решение с програма</h3>
Примерно <a href="https://en.wikipedia.org/wiki/Brute-force_search" target=_blank>Brute-force</a> решение би било да проверим програматично всички естествени числа n например до <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#MAX_VALUE" target=_blank>Integer.MAX_VALUE</a> = 2<sup>31</sup>-1. За да избегнем <a href="https://javapapers.com/core-java/java-overflow-and-underflow/" target=_blank>Integer overflow</a> в аритметичните изрази, трябва да дефинираме променливите n и x от тип long.
{:/}
```java
for (long n=1; n<Integer.MAX_VALUE; n++) {
    long x = (long) Math.sqrt(n*n + 2019);
    if (n*n + 2019 == x*x) {
    	System.out.println(n + "^2 + 2019 = " + x + "^2");
    }
}
```
{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">
335^2 + 2019 = 338^2<br>
1009^2 + 2019 = 1010^2
</div>
Виждаме, че решения имаме само за сравнително малки стойности на n, което ни навежда на идеята да оценим максимално допустимите стойности за n.<br>
Tъй като \(n^2+2019=x^2 \Rightarrow (x-n)(x+n)=2019 \Rightarrow x+n \leq 2019 \iff \)
\( \sqrt{n^2+2019}+n \leq 2019 \). Тъй като \( \sqrt{n^2+2019} &gt; n \), то следва, че  \( 2n &lt; 2019 \iff n &lt; 1009.5 \Rightarrow n \leq 1009 \)<br>
С това доказахме, че намерените <b>2 решения</b> са единствени.
	</div> 
</div>
{:/}

<hr>

Тройка на Питагор формират всеки 3 естествени числа a,b и c, всичките по-големи от 1, такива че а<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>.<br>
Колко са тройките на Питагор, при които най-малкото число е ≤ 10000, ако приемем, че наредбата на числата няма значение?<br>
Пример: (10000,10500,14500) и (10500,10000,14500) са една и съща тройка на Питагор, отговаряща на условието.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution43><label for=solution43 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

{:/}

Ако не знаем от къде да започнем, време е за <a href="https://www.google.com/search?q=generate+pythagorean+triples&rlz=1C1CHBF_enBG782BG782&oq=generate+p&aqs=chrome.3.69i57j0j35i39l2j0l2.10599j0j7&sourceid=chrome&ie=UTF-8" target="_blank">Google</a>.<br>
Eдин конкретен алгоритъм за генериране на тройки на Питагор, например, е чрез <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple" target="_blank">формулата на Евклид</a>:<br>
Ако  \\( m \\) и  \\( n \\) са произволни естествени числа, такива че \\( m &gt; n &gt; 0 \\), то тогава ( \\( m^2 – n^2 , 2mn , m^2 + n^2 \\) ) e тройка на Питагор. Очевидно  \\( m \neq n \\), тъй като при равенство \\( m^2 + n^2 = m^2 + m^2 = 2m^2 \\), което няма как да е точен квадрат. <br>
С какво трябва да се съобразим?<br>
- Всички примитивни тройки на Питагор се генерират точно веднъж, когато и само когато числата \\( m \\) и \\( n \\) са взаимно прости и не едновременно нечетни. Понеже се интересуваме от всички тройки, не само примитивните, останалите трябва да генерираме сами, както и да се погрижим за това, да не преброим една и съща тройка 2 пъти.
- Ясно е, че най-голямото число от така генерираната тройка е  \\( m^2 + n^2 \\), понеже \\( (m^2 + n^2) - (m^2 - n^2) = 2n^2 &gt; 0,  (m^2 + n^2) - 2mn = (m-n)^2 &gt; 0\\), но не е ясно кое е най-малкото. Пример: при \\( m=2, n=1, m^2 – n^2=3&lt; 2mn=4 \\), a при \\( m=4, n=1, m^2 – n^2=15&gt; 2mn=8 \\)
- Трябва да генерираме всички възможни двойки \\( m \\) и  \\( n \\), такива че \\( m^2 – n^2 \leq 10000 \\) или \\(2mn \leq 10000 \\).<br>
Оценка на големината на \\( m + n \\), необходима при някои решения:
     - Каква е максималната стойност на  \\( m + n \\), такава че съществуват числа \\( m^2 – n^2 \leq 10000\\)?
\\( m^2 – n^2 \leq 10000 \iff (m + n)(m - n) \leq 10000 \Rightarrow m + n \leq \dfrac{10000}{m - n} \leq 10000 \\)
     - Каква е максималната стойност на  \\( m + n \\), такава че съществуват числа \\( 2mn \leq 10000\\) ?<br>
\\( 2mn \leq 10000 \iff mn \leq 5000 \Rightarrow n \leq \dfrac{5000}{m}, m \leq 5000 \\)   \\( \Rightarrow m+n \leq m + \dfrac{5000}{m} \leq 5001 \\). 

{::nomarkdown}
Тъй като работата с тройка обекти е сравнително стандартна и често срещана ситуация, вместо да дефинираме наш собствен клас, можем да потърсим вече съществуваща имплементация с отворен код и подходящ лиценз, например клас <a href="https://commons.apache.org/proper/commons-lang/apidocs/index.html?org/apache/commons/lang3/tuple/Triple.html" target=_blank>ImmutableTriple</a> от Apache Commons Lang библиотеката.
Допълнителни оптимизации, като например това да пазим само първите две числа на тройките на Питагор (клас <a href="https://commons.apache.org/proper/commons-lang/apidocs/index.html?org/apache/commons/lang3/tuple/ImmutablePair.html" target=_blank>ImmutablePair</a>), също са възможни, но не са наложителни в конкретния случай.
{:/}

```java
private void buildResult(Set<ImmutableTriple<Integer,Integer,Integer>> result, final int limit) {
    for(int m = 2; m < limit; m++) {
    	for (int n = 1; n < m && n + m <= limit; n++) {
            int a = m * m - n * n;
            int b = 2 * m * n;
            int c = m * m + n * n;
            if (a > b) {
            	int tmp = a;
            	a = b;
            	b = tmp;
            }
            int multiplyBy = 1;
            while (a*multiplyBy <= limit) {
            	result.add(new ImmutableTriple<>(a*multiplyBy, b*multiplyBy, c*multiplyBy));
            	multiplyBy++;
            }
    	}
    }
}
```
```java
Set<ImmutableTriple<Integer,Integer,Integer>> result = new HashSet<>();
buildResult(result, 10000);
System.out.println(result.size());
```
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">99773</div>
<br>
Ако искаме да генерираме всяка тройка точно по веднъж, трябва да проверяваме, че \\( m \\) и  \\( n \\) са взаимно прости, т.е. най-големият им общ делител (НОД) = 1 и не са едновременно четни.
```java
private int gcd(int a, int b) {
	if (a == 0) return b;
	return gcd(b%a, a);	
}
```
```java
int limit = 10000;
int numberOfTriples = 0;
// k = m + n
for(int k=3; k <= limit; k+=2) {
	int n = 1;
	int m = k-n;
	while (n < m) {	
		if (gcd(m,n) == 1) {
			int a = m*m - n*n;
			int b = 2*m*n;
			//int c = m*m + n*n;
			if (a > b) {
				int tmp = a;
				a = b;
				b = tmp;
			}
			int multiplyBy = 1;
			while (a*multiplyBy <= limit) {
				//The next triple is (a*multiplyBy , b*multiplyBy , c*multiplyBy) 
				numberOfTriples++;
				multiplyBy++;
			}
		}
		n++;
		m--;
	}
}
System.out.println(numberOfTriples);
```
{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">99773</div>

<br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week4/PythagoreanTripleGenerator.java" target="_blank">Примерен Java код, генериращ повтарящи се тройки</a>
<br>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week4/PythagoreanTripleUniqueGenerator.java" target="_blank">Примерен Java код, генериращ уникалните тройки точно по веднъж</a>
	</div> 
</div>
</div>

<input type="checkbox" id=week5Toggle>
<label for=week5Toggle class="week">
<h2 id=week5>Седмица №5 <span></span></h2>
</label>	
<div>
	


<p>
Спринтьор прави една обиколка на пистата със средна скорост V<sub>1</sub>. Времето му се струва твърде слабо, затова спонтанно решава (без да спира) да изтича втората обиколка по-бързо, така че общата средна скорост от двете обиколки да бъде два пъти по-голяма от V<sub>1</sub>. С каква средна скорост V<sub>2</sub> спринтьорът трябва да изтича втората си обиколка, за да постигне това?
</p>

<ul class="answersWithRadio">
	<li> V<sub>2</sub> не може да се определи, защото зависи от дължината на пистата</li>
	<li> V<sub>2</sub>=2∗V<sub>1</sub></li>
	<li> V<sub>2</sub>=3∗V<sub>1</sub></li>
	<li> V<sub>2</sub>=4∗V<sub>1</sub></li>
	<li> V<sub>2</sub>=8∗V<sub>1</sub></li>
	<li> Независимо колко бързо тича, спринтьорът няма как да постигне обща средна скорост, равна на 2∗V<sub>1</sub></li>
</ul>

<div>
	<input type="checkbox" id=solution51><label for=solution51 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Знаем, че V=S/t.<br>
Разстоянието и на двете обиколки е едно и също (S).<br>
Нека първата обиколка е взета за време t<sub>1</sub>, а втората за време t<sub>2</sub>.<br>
Тогава V<sub>1</sub>=S/t<sub>1</sub>, a V<sub>2</sub>=S/t<sub>2</sub>.<br>
Общата средната скорост за двете обиколки е равна на целия път, разделен на цялото време, т.е. V<sub>средно</sub>=2∗S/(t<sub>1</sub>+t<sub>2</sub>).<br>
Искаме V<sub>средно</sub>=2V<sub>1</sub>=2S/t<sub>1</sub>.<br>
Т.е. \( \dfrac{2S}{t_1} = \dfrac{2S}{t_1+t_2}  \), откъдето следва, че t<sub>2</sub>=0, което е невъзможно и 
<br><b>независимо колко бързо тича, спринтьорът няма как да постигне обща средна скорост, равна на 2∗V1</b>.	
<ul class="answersWithRadio">
	<li class="notCorrectAnswer"> V<sub>2</sub> не може да се определи, защото зависи от дължината на пистата</li>
	<li class="notCorrectAnswer"> V<sub>2</sub>=2∗V<sub>1</sub></li>
	<li class="notCorrectAnswer"> V<sub>2</sub>=3∗V<sub>1</sub></li>
	<li class="notCorrectAnswer"> V<sub>2</sub>=4∗V<sub>1</sub></li>
	<li class="notCorrectAnswer"> V<sub>2</sub>=8∗V<sub>1</sub></li>
	<li class="correctAnswer"> Независимо колко бързо тича, спринтьорът няма как да постигне обща средна скорост, равна на 2∗V<sub>1</sub></li>
</ul>

	</div>	
</div>
<hr>
<p>
Ася живее на 3 км от брега на морето, а къщата на баба ѝ е на 5 км от брега.<br>
Една сутрин Ася решава да посети баба си, като преди това отиде до брега, за да съзерцава изгрева.<br>
Ако приемем, че брегът е права линия, най-близката точка от брега до къщата на Ася е A<sub>0</sub>, най-близката точка от брега до къщата на бабата на Ася е B<sub>0</sub> и разстоянието от A<sub>0</sub> до B<sub>0</sub> е 10 км, какъв е най-късият път (в км), който Ася може да измине, спечелвайки по този начин най-много време за съзерцание?<br>
Отговорете с точност две цифри след десетичната запетая (закръглете до стотни).
	<img src="/technoteaser/docs/images/2019/1IadWtrk59n_XitiEV35fqwo8L8feotZR8GlzjdLa_M.jfif" style="display:block; max-width:100%;height:auto;border:0;">
</p>
<div>
	<input type="checkbox" id=solution52><label for=solution52 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
	
<h3 id="week5,solution52,Решение_на_програмиста">Решението на програмиста:</h3>
Нека Ася съзерцава морето в точка С, такава че АС+СВ е с най-малка дължина.<br>
Минимумът математика, с който така или иначе се сблъскахме <a href="/services/web/TechQuiz/user/#/questions/67" target=_blank>миналата седмица</a>, е да приложим два пъти формулата на Питагор за правоъгълен триъгълник. Ако А<sub>0</sub>С=х, то СВ<sub>0</sub>=10-х и за целия път получаваме  \(\sqrt{3^2+x^2}+\sqrt{5^2+(10-x)^2}\) 
<br>
Как да намерим за кое х пътят е най-къс и колко точно е той?<br>
Знаем, че точката С е някъде на отсечката А<sub>0</sub>В<sub>0</sub> и за всяка друга точка, отдалечавайки се от нея, общият път ще се увеличава. 
Тъй като не търсим безкрайна точност, можем да си позволим да търсим т. С с приближение, като пробваме какво разстояние получаваме за различни точки. За целта:

{:/}

1. Ще изчислим общия път за всяка точка, отдалечена на цяло число километри от А<sub>0</sub> (проверяваме точки със стъпка от 1 км). Така ще намерим точка с най-къс общ път С<sub>1</sub>
2. Ще изчислим пътя за всяка точка на отстояние +- 1 км от С<sub>1</sub>, със стъпка 0,1 км. Така ще намерим следваща точка с най-добър път С<sub>2</sub>
3. Ще продължим да намаляваме проверявания интервал и съответно стъпката между проверяваните точки, докато се убедим, че сме намерили най-късия път със задоволителна точност.

```java
public double getXforTheLeastTimePath(double fromX, double toX, double step) {
	double minPath =  Double.MAX_VALUE;
	double xForTheMinPath = 0;
	for(double x=fromX; x<toX; x+=step) {
		double currentPath = Math.sqrt(x*x + 9) + Math.sqrt((10-x)*(10-x) + 25);
		if (minPath > currentPath) {
			minPath = currentPath;
			xForTheMinPath = x;
		}
	System.out.println("For X from " + fromX + " to " + toX + " with step " + step + ":");
	System.out.println("\t  Min distance=" + minPath + " km for X=" +  xForTheMinPath);
	}
}
```
```java
double x= getXforTheLeastTimePath(0, 10, 1);
x = getXforTheLeastTimePath(x-1, x+1, 0.1);
x = getXforTheLeastTimePath(x-0.1, x+0.1, 0.01);
x = getXforTheLeastTimePath(x-0.01, x+0.01, 0.001);
	
```

{::nomarkdown}

<div style="background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">For X from 0.0 to 10.0 with step 1.0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.810249675906654 km for X=4.0</br>
For X from 3.0 to 5.0 with step 0.1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.806410475460032 km for X=3.8000000000000007<br>
For X from 3.7000000000000006 to 3.900000000000001 with step 0.01:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.806248474865697 km for X=3.7499999999999996<br>
For X from 3.7399999999999998 to 3.7599999999999993 with step 0.001:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.806248474865697 km for X=3.7499999999999987</div><br>
Откъдето получаваме и отговора за най-къс път от 12,806248474865697 км ≈ **12,81** <br>
Резултатът от изпълнението на програмата показва и приближението, което винаги присъства при работата с типове данни с плаваща запетая (например добавяйки 8 пъти 0,1 към числото 3 дава резултат 3.8000000000000007)

<h3 id="week5,solution52,Решение_на_математика">Решението на математика:</h3>

Ще проектираме къщата на бабата (т. В) спрямо линията на брега в т. В‘ <br>
<img style="max-width: 100%; object-fit: contain; " src="/technoteaser/docs/images/2019/w6KPyWwjaTev_d624zOaGNGPRXNqVMn2_B4hbV36Uhk.png"><br>
Най-късият път от А до В‘ ще бъде правата линия от А до В‘. Ако АВ‘ пресича брега (А<sub>0</sub>B<sub>0</sub>) в т. С, то АС + СВ ще бъде най-късият път и за Ася. Това твърдение се доказва лесно, защото ако предположим, че има друга т. С<sub>1</sub> върху А<sub>0</sub>B<sub>0</sub>, такава че АС<sub>1</sub>+С<sub>1</sub>В &lt; АС+ВС , то понеже С<sub>1</sub>В=С<sub>1</sub>В‘ ще следва, че АС<sub>1</sub>+С<sub>1</sub>В‘ &lt; АВ‘, което е невъзможно, тъй като най-краткият път между А и В‘ е правата линия.
Как да намерим АВ‘=АС+СВ‘?
Тъй като △A<sub>0</sub>AC ~ △В<sub>0</sub>В‘С, то А<sub>0</sub>С/В<sub>0</sub>С=AA<sub>0</sub>/BB<sub>0</sub>=3/5, а ние знаем, че А<sub>0</sub>С+В<sub>0</sub>С=10 ⇒ A<sub>0</sub>C=3.75, В<sub>0</sub>С=6.25<br>
За най-къс път получаваме \(\sqrt{3^2+3,75^2}+\sqrt{5^2+6,25^2}\)  = <a href="https://www.google.bg/search?q=sqrt%283*3%2B3.75*3.75%29+%2B+sqrt%285*5%2B6.25*6.25%29&rlz=1C1CHBF_enBG782BG782&oq=sqrt%283*3%2B3.75*3.75%29+%2B+sqrt%285*5%2B6.25*6.25%29" target=_blank title="пресметни в Google">12,8062484749</a> ≈ <b>12,81</b>

<h3 id="week5,solution52,Решение_на_физика">Решението на физика:</h3>

Най-късият път е този, при който ъгълът, под който Ася се доближава към брега, е същият като ъгъла, под който тя трябва да се отдалечава от него (∠АСА<sub>0</sub>=∠ВСВ<sub>0</sub>)<br>
Защо това е така – вижте решението на физика в следващата задача.<br>
От тук нататък повтаряме решението на математика без нуждата от допълнително построение върху чертежа, показвайки, че △A<sub>0</sub>AC ~ △В<sub>0</sub>ВС	
	
<br><br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week5/ReflectionPath.java" target="_blank">Примерен Java код</a>
	</div>
</div>	
<hr>
<p>
Асен също живее на 3 км от брега и иска да отиде при дядо си, който в този момент е на лодка навътре в морето.<br>
Ако лодката е на 5 км навътре в морето и на 10 км от къщата на Асен, каква е дължината на най-бързия път за Асен (в км), ако той плува два пъти по-бавно отколкото ходи?<br>Отговорете с точност 2 цифри след десетичната запетая (закръглете до стотни).
	<img src="/technoteaser/docs/images/2019/c_8cYGziR3KEyp3CqfjYiZeLXIyeMOzV8-omlrSgpWE.jfif" style="display:block; max-width:100%;height:auto;border:0;">
</p>
<div>
	<input type="checkbox" id=solution53><label for=solution53 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

Тъй като част от пътя си Асен изминава с два пъти по-бавна скорост, то най-бързият път не е непременно най-късият - факт, който спасителите на плажа познават добре.
<h3 id="week5,solution53,Решение_на_програмиста" title="Няколко реда код">Решението на програмиста:</h3>
Ще повторим подхода от предходната задача с Ася, като единствената разлика тук е в начина, по който пресмятаме най-доброто време. Също така ще трябва да пресметнем сами дължината на А<sub>0</sub>В<sub>0</sub><br>
Тъй като △AA<sub>0</sub>C ~ △ВВ<sub>0</sub>С, АС/ВС=3/5, а АС+СВ=10 ⇒ АС=3,75 а ВС=6,25 ⇒ А<sub>0</sub>B<sub>0</sub>=А<sub>0</sub>C+CB<sub>0</sub>=  \(\sqrt{3,75^2-3^2}+\sqrt{6,25^2-5^2}=6\)  <br>
За улеснения в сметките, ще предположим, че Асен ходи със скорост 1 км/ч и плува с 0,5 км/ч. Сравнително лесно се забелязва, че промяната на скоростите на ходене пеша и плуване, като запазваме съотношението между тях, не променя точката на брега Х, даваща най-бърз път, и не променя дължината на този път. За примерния код по-долу това означава, че няма значение дали търсим минимума на d1 + 2\*d2 или на (d1 + 2*d2)*n

{:/}

```java
public double getXforTheLeastTimePath(double fromX, double toX, double step) {
	double leastTime = 100000;
	double distanceOfTheLeastTimePath = 0;
	double xForTheLeastTimePath = 0;
	for (double x=fromX; x<=toX; x+=step) {
		double d1 = Math.sqrt(x*x + 9); 
		double d2 = Math.sqrt((6-x)*(6-x) + 25);
		double currentPathTime = d1 + 2*d2;
		if (leastTime > currentPathTime) {
			leastTime = currentPathTime;
			distanceOfTheLeastTimePath=d1 + d2;
			xForTheLeastTimePath = x;
		}
	}
	System.out.println("For x from " + fromX + " to " + toX + " with step " + step + ":");
	System.out.println("\tLeast time=" + leastTime + " for x=" +  xForTheLeastTimePath + " with overall distance=" + distanceOfTheLeastTimePath + " km");
	return xForTheLeastTimePath;
}
```
```java
double x= getXforTheLeastTimePath(0, 6, 1);
x = getXforTheLeastTimePath(x-1, x+1, 0.1);
x = getXforTheLeastTimePath(x-0.1, x+0.1, 0.01);
x = getXforTheLeastTimePath(x-0.01, x+0.01, 0.001);
x = getXforTheLeastTimePath(x-0.001, x+0.001, 0.0001);
```

{::nomarkdown}
<div style="background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">For x from 0.0 to 6.0 with step 1.0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.770329614269007 for x=4.0 with overall distance=10.385164807134505 km<br>
For x from 3.0 to 5.0 with step 0.1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766563330422017 for x=3.900000000000001 with overall distance=10.343464585239516 km<br>
For x from 3.8000000000000007 to 4.000000000000001 with step 0.01:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766141051110553 for x=3.8499999999999996 with overall distance=10.323485449292631 km<br>
For x from 3.84 to 3.8599999999999994 with step 0.001:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766139029493285 for x=3.8529999999999984 with overall distance=10.3246678129931 km<br>
For x from 3.8519999999999985 to 3.8539999999999983 with step 1.0E-4:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766139018747975 for x=3.853200000000001 with overall distance=10.32474671162657 km<br></div>
Получаваме разстояние от 10,32474671162657 ≈ <b>10,32</b> км
<h3 id="week5,solution53,Решение_на_математика" title="Tук трябва да сте сигурни в познанията си по математически анализ!">Решението на математика:</h3>

<img style="max-width: 100%; object-fit: contain; " src="/technoteaser/docs/images/2019/A0DGbB3Js6CQx1Gscr8cbGdfiLL3MVJs-qoIWZYvQzE.png"><br>

\(A_0B_0=\sqrt{3,75^2-3^2}+\sqrt{6,25^2-5^2}=6 \)<br>
\(AX=d_1=\sqrt{3^2+x^2}\)<br>
\(BX=d_2=\sqrt{5^2+(6-x)^2}\)<br>

Търсим минимума на общото време \(T=Т_{пеша}+Т_{плуване}= \dfrac{d_1}{V_{пеша}}+\dfrac{d_2}{V_{плуване} }=\dfrac{\sqrt{3^2+x^2} }{V_{пеша}} + \dfrac{\sqrt{5^2+(6-x)^2}}{V_{плуване}}\)<br>
\(\dfrac{\partial T}{\partial x}=\dfrac{x}{V_{пеша}\sqrt{3^2+x^2}}-\dfrac{6-x}{V_{плуване}\sqrt{5^2+(6-x)^2} }=0\)<br>
когато \(\dfrac{6-x}{V_{плуване}\sqrt{5^2+(6-x)^2}}=\dfrac{x}{V_{пеша}\sqrt{3^2+x^2}}\) <br>
което е равносилно на \(\dfrac{V_{пеша} }{V_{плуване}}=\dfrac{x\sqrt{5^2+(6-x)^2} }{(6-x)\sqrt{3^2+x^2 }}=2\)<br>
Сметките стават отвратителни, но един математик никога не се отказва.<br>
Нека разгледаме графиката на \(x\sqrt{5^2+(6-x)^2} -2(6-x)\sqrt{3^2+x^2}=0\) 
<a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=1GP5W9OEIajprgTkxaQI&q=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+0+to+6&oq=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+0+to+6&gs_l=psy-ab.3...72291.141007..142663...2.0..0.331.4462.42j3j0j1......0....1..gws-wiz.......0i8i30j35i39j35i304i39.fCmXxa0ybUk" target="_blank">за x от 0 до 6 </a> (интервалът, от който се интересуваме), по-малкия интервал
<a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=Y2T5W_yWNuj6qwG274vIDQ&q=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8+to+3.9&oq=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8+to+3.9&gs_l=psy-ab.3...54201.59179..59383...0.0..0.93.701.8......0....1..gws-wiz.......0i71.YrE3ECnW6ME" target="_blank"> за x от 3,8 до 3,9</a>, където y=0, и накрая
<a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=oGT5W5mAGLLprgSPnb6oBA&q=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8532385+to+3.8532387&oq=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8532385+to+3.8532387&gs_l=psy-ab.3...22884.31761..32517...0.0..0.88.673.8......0....1j2..gws-wiz.YMC5y3POHik" target="_blank">около x=3,8532386</a><br>
Така накарахме Google да пресметне корена на уравнението в търсения от нас интервал вместо нас. Без да ползваме Google, решението евентуално би минало през уравнението \(3x^4-36x^3+119x^2-432x+1296=0\) в интервала [0,6], за което можем да ползваме <a target="_blank"  href="http://www.fmi-plovdiv.org/evlm/DBbg/database/courses/2%20lekcia-k4m-2012.pdf">метода на разполовяването, на хордите или на допирателните</a>.<br>
В тази точка имаме минимум на функцията за общото време T=Т<sub>пеша</sub>+Т<sub>плуване</sub>, понеже при V<sub>пеша</sub>=1, V<sub>плуване</sub>=0,5 и x&lt;3,8532386 (например x=3,8) \(\dfrac{\partial T}{\partial x}\)&lt;0, т.е. функцията намалява, a при x&gt;3,8532386 (например x=3,9) \(\dfrac{\partial T}{\partial x}\)&gt;0, т.е. функцията нараства.<br> 
Пресмятаме \(d_1+d_2=\sqrt{3^2+x^2}+\sqrt{5^2+(6-x)^2}\) за x=3,8532386 и получаваме <a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=6xj5W-C5LoSzsAfE0JK4CA&q=calc+sqrt%283%5E2%2B3.8532386%5E2%29%2Bsqrt%285%5E2%2B%286-3.8532386%29%5E2%29&oq=calc+sqrt%283%5E2%2B3.8532386%5E2%29%2Bsqrt%285%5E2%2B%286-3.8532386%29%5E2%29&gs_l=psy-ab.3...63869.66508..67435...0.0..0.89.171.2......0....1j2..gws-wiz.......0i71j35i302i39.Mz_WU5xOtGM" target="_blank">10,3247619401</a>≈<b>10,32</b> км

<h3 id="week5,solution53,Решение_на_физика" title="От мистика към реалност">Решението на физика:</h3>

Най-бързият път между две точки е този, който светлината би изминала между тях. Това е принципа на Ферма, формулиран за първи път в далечния 1-ви януари 1662 г.<br>В общия случай може да има и повече от един най-бърз път (пътища с еднакво време).<br>
Когато между двете точки няма препятствия и промяна на скоростта, това е просто правата линия.<br>
Когато имаме отражение, както в предходната задача, тогава ъгълът на падане е равен на ъгъла на отражение. Тъй като няма промяна в скоростта, най-бързият и най-краткият път за предходната задача съвпадат.<br>
Когато светлината преминава от една среда в друга и това води до промяна в скоростта, тогава наблюдаваме пречупване (рефракция), като ъгълът на пречупване се определя от закона на Снел (Снелиус) \(\dfrac{V_1}{V_2}=\dfrac{\sin{\theta_2} }{\sin{\theta_1}}=\dfrac{x\sqrt{5^2+(d-x)^2} }{(d-x)\sqrt{3^2+x^2}}=2\) и това в случая е относителният коефициент на пречупване на втората среда спрямо първата. Като вземем тази формула наготово, спестявайки си изследването на функцията за минимум през първа производна, следват останалите изчисленията, които остават все така неизбежни.<br>
<hr>
Как светлината намира винаги най-бързия път между две точки?<br>
Всъщност това тя прави не благодарение на квантовите си свойства, като преминава през всички възможни пътища и като прави квантов скок за най-бързия от тях. Светлината е вълна, а правилото за най-бърз път важи за вълните по принцип, включително и за тези, които нямат отношение към квантовата механика, като например звуковите и морските вълни.<br>
Дали това е просто случайно следствие на вълновите свойства в природата, или пък природата не е имала друг избор, това е вече главоблъсканица от философско измерение, но както е видно по-горе понякога и няколко реда код вършат достатъчно добра работа.	

<br><br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week5/RefractionPath.java" target="_blank">Примерен Java код</a>
	</div>
</div>
</div>


<input type="checkbox" id=week6Toggle>
<label for=week6Toggle class="week">
<h2 id=week6>Седмица №6 <span></span></h2>
</label>	
<div>
<p>
Ако \(a \ne 0, b \ne 0, c \ne 0, \)  \(а +b + c \ne 0\) и<br>
\(\dfrac{a + b}{c}=m \\ \dfrac{b + c}{a}=n\)<br>
да се намери \( \dfrac{a + c}{b} = \text{?} \)
</p>
<div>
	<input type="checkbox" id=solution61><label class="explanationbutton" for=solution61><span>Обяснение</span></label>
	<div class="explanation">

\( \dfrac{a + b}{c}=m \iff  \dfrac{a + b}{c}+1=m+1  \iff \dfrac{a + b + c}{c}=m+1\) <br>
\( \dfrac{b + c}{a}=n \iff \dfrac{a + b + c}{a}=n+1 \) <br>
\( \text{ От } a+b+c \ne 0 \Rightarrow \)
<ol><li>
\( \dfrac{a + b + c}{c}=m+1 \iff \dfrac{c}{a + b + c}=\dfrac{1}{m+1} \text{  (1)} \) 
</li><li>
\( \dfrac{a + b + c}{a}=n+1 \iff \dfrac{a}{a + b + c}=\dfrac{1}{n+1} \text{  (2)} \) 
</li></ol>
\(  \text{Събираме (1) и (2)}\) <br>
\( \dfrac{c}{a + b + c} + \dfrac{a}{a + b + c} = \dfrac{1}{m+1}+\dfrac{1}{n+1} \iff \) <br>
\(  \dfrac{a+c}{a + b + c} = \dfrac{m+1+n+1}{(m+1)(n+1)} \iff \) <br>
\(  \dfrac{a+b+c}{a + b + c } - \dfrac{b}{a + b + c} = \dfrac{m+n+2}{(m+1)(n+1)} \iff \) <br>
\(  \dfrac{b}{a + b + c} = 1 - \dfrac{m+n+2}{(m+1)(n+1)} \iff \)  <br>
\( \dfrac{b}{a + b + c} = \dfrac{mn-1}{(m+1)(n+1)} \iff \) <br>
\( \dfrac{a + b + c}{b} = \dfrac{(m+1)(n+1)}{mn-1} \iff \) <br>
\( \dfrac{a + c}{b} +1 = \dfrac{mn+m+n+1}{mn-1} \iff \) <br>
\( \mathbf{ \dfrac{a + c}{b}  = \dfrac{m+n+2}{mn-1} } \)

	</div>
</div>

<hr>
<p>
Ако за дума считаме всеки набор от букви, то колко различни думи могат да бъдат съставени от думата САПТЕХНОБЛЪСКАНИЦА (като броим и самата нея), сменяйки местата на буквите, така че да са изпълнени следните условия:
<ol type='1'>
<li> Буквите С, А и П да присъстват в думата задължително заедно (без други букви между тях) и в този ред.</li>
<li> Да няма две съседни гласни.</li>
<li> Да няма три съседни съгласни.</li>
<li> За двойките съседни съгласни в думата да е изпълнено, че за всяка нечетна по ред двойка първата съгласна е лексикографски по-малка от втората, а за всяка четна по ред двойка първата съгласна е лексикографски по-голяма от втората.</li>
</ol>
Пример: думата САПТЕХНОБЛЪСКАНИЦА отговаря на всички условия, като за двойките съседни съгласни е изпълнено, че (1) П&lt;Т, (2) Х&gt;Н, (3) Б&lt;Л, (4) С&gt;К
</p>
<div>
	<input type="checkbox" id=solution62><label class="explanationbutton" for=solution62><span>Обяснение</span></label>
	<div class="explanation">

С какво трябва да се съобразим при <a href="https://en.wikipedia.org/wiki/Brute-force_search" target=_blank>Brute-force</a> подход?

{:/}

- Буквите С, А и П можем да разглеждаме като една буква (нека я означим с S), като:
     - S разглеждаме като съгласна буква.
     - Трябва да напишем наша логика за лексикографско сравнение на две букви, когато едната от тях е S, като например просто заменяме S с П, когато S е първа буква и S със С, когато S е втора буква и продължаваме със стандартната логика за сравняване. Трябва да внимаваме да не използваме тази логика за сортиране на думи, включително в сортирани структури от данни, тъй като <nobr>S&lt;С, a С==S, както и S==П, а П&lt;S</nobr>.
- Тъй като задачата по същество търси брой пермутации с повторение, най-лесният начин за генерирането на думите точно по веднъж е рекурсивният.

```java
private final Comparator<Character> SAP_LETTER_COMPARATOR = (Character c1, Character c2) -> {
	if (c1 == 'S' && c2 == 'S') {
		throw new IllegalArgumentException("Comparing 2 S characters");
	}
	if (c1 == 'S') {
		c1 = 'П';
	} else if (c2 == 'S') {
		c2 = 'С';
	}
	return c1.compareTo(c2);
};
```
Инициализация на буквите, с които работим:
```java
static private Map<Character, Integer> inputOfVowels = new HashMap<Character, Integer>(); 
static private Map<Character, Integer> inputOfConsonants = new HashMap<Character, Integer>();
static {
	inputOfVowels.put('А', 2);
	inputOfVowels.put('Е', 1);
	inputOfVowels.put('О', 1);
	inputOfVowels.put('И', 1);
	inputOfVowels.put('Ъ', 1);
	
	inputOfConsonants.put('Н', 2);
	inputOfConsonants.put('Т', 1);
	inputOfConsonants.put('Х', 1);
	inputOfConsonants.put('Б', 1);
	inputOfConsonants.put('Л', 1);
	inputOfConsonants.put('С', 1);
	inputOfConsonants.put('К', 1);
	inputOfConsonants.put('Ц', 1);
	inputOfConsonants.put('S', 1);
}
```
```java
private static long calculateNumberOfWords(char lastLetter, LetterType lastLetterType, int numberOfConsonantPairs) {
		
	Set<Character> availableVowels = new HashSet<>(currentVowels.keySet());
	Set<Character> availableConsonants = new HashSet<>(currentConsonants.keySet());
	
	if (availableVowels.isEmpty() && availableConsonants.isEmpty()) {
		// recursion base case
		return 1;		
	} 
	
	long result = 0; 
	
	if (lastLetterType != LetterType.VOWEL) {
		for(Character nextVowelChar : availableVowels) {
			int occurrencesOfNextVowel = currentVowels.get(nextVowelChar);
			if (occurrencesOfNextVowel == 1) {
				currentVowels.remove(nextVowelChar);
			} else {
				currentVowels.put(nextVowelChar, occurrencesOfNextVowel-1);
			}
			result += calculateNumberOfWords(nextVowelChar, LetterType.VOWEL, numberOfConsonantPairs);
			//revert the input before we continue 
			currentVowels.put(nextVowelChar, occurrencesOfNextVowel);
		}
	} 
	
    if (lastLetterType != LetterType.CONSECUTIVE_CONSONANT) {
		LetterType nextLetterType = lastLetterType==LetterType.CONSONANT ? LetterType.CONSECUTIVE_CONSONANT : LetterType.CONSONANT;
		
		for(Character nextConsonantChar : availableConsonants) {
			if (lastLetterType == LetterType.CONSONANT) {
				if (numberOfConsonantPairs%2 == 0 && 
					SAP_LETTER_COMPARATOR.compare(lastLetter, nextConsonantChar) >= 0) continue;

				if (numberOfConsonantPairs%2 == 1 && 
					SAP_LETTER_COMPARATOR.compare(lastLetter, nextConsonantChar) <= 0) continue;		
			}	
			int occurrencesOfNextConsonant = currentConsonants.get(nextConsonantChar);
			if (occurrencesOfNextConsonant == 1) {
				currentConsonants.remove(nextConsonantChar);
			} else {
				currentConsonants.put(nextConsonantChar, occurrencesOfNextConsonant-1);
			}
			
			int nextNumberOfConsonantPairs = lastLetterType==LetterType.CONSONANT ? numberOfConsonantPairs + 1 : numberOfConsonantPairs;
			if (nextConsonantChar == 'S') {
				//allow Consonant S Consonant triple
				result += calculateNumberOfWords(nextConsonantChar, LetterType.CONSONANT, nextNumberOfConsonantPairs);
			} else {
				result += calculateNumberOfWords(nextConsonantChar, nextLetterType, nextNumberOfConsonantPairs);
			}
			
			//revert the input before we continue 
			currentConsonants.put(nextConsonantChar, occurrencesOfNextConsonant);
		}
	}
    
    return result;
}
```
```java
long result = calculateNumberOfWords((char)0, null, 0);
System.out.println("Number of words:" + result);
```
И въоръжени с юнашко търпение, от порядъка на час, получаваме:

{::nomarkdown}

<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">4419100800</div>
<br>
Може ли по-добре? Би било странно да не може.<br>
Алгоритмите, които броят всички възможности чрез генерирането им, при задачи от областта на комбинаториката, имат експоненциална сложност и това се вижда лесно във формулите от самата комбинаториката. Ако игнорираме условията за съседни гласни и съгласни, като все още броим буквите С, А и П като една, броят на всички думи по формулата за брой <a href="https://store.fmi.uni-sofia.bg/fmi/algebra/Resources/combinatorics.pdf" target=_blank>пермутации с повторения</a> ще бъде равен на <nobr>\( \dfrac{16!}{2!*2!} \) = 5230697472000.</nobr> Идеите за оптимизация обикновено са свързани просто с използването на формулите от комбинаториката там, където това е възможно.<br>
Имаме 10 съгласни (с повтарящо се Н, а САП е една съгласна) и шест гласни (с повтарящо се А).
- По колко различни начина могат да се разпределят шест гласни, оставяйки места за 10 единични или двойка съседни съгласни между тях?<br>
Ако съгласните (независимо дали са единични или двойка съседни) означим с _, а всяка от гласните с Г<sub>i</sub>, ще получим следните възможности:  
<ol>
<li><nobr>_ Г<sub>1</sub> _ Г<sub>2</sub> _ Г<sub>3</sub> _ Г<sub>4</sub> _ Г<sub>5</sub> _ Г<sub>6</sub> _ </nobr> за думи със седем места за съгласни, в три от които ще бъдат двойка съседни.</li>
<li><nobr>_ Г<sub>1</sub> _ Г<sub>2</sub> _ Г<sub>3</sub> _ Г<sub>4</sub> _ Г<sub>5</sub> _ Г<sub>6</sub> + </nobr>
<nobr>Г<sub>1</sub> _ Г<sub>2</sub> _ Г<sub>3</sub> _Г <sub>4</sub> _ Г<sub>5</sub> _ Г<sub>6</sub> _</nobr> за думи с шест места за съгласни, в четири от които ще бъдат двойка съседни.</li>
<li><nobr>Г<sub>1</sub> _ Г<sub>2</sub> _ Г<sub>3</sub> _ Г<sub>4</sub> _ Г<sub>5</sub> _ Г<sub>6</sub></nobr> за думи с пет места, всички от които за двойка (без единични) съгласни.</li>
</ol>
Ако намерим възможностите за разпределение на съгласните за конкретен случай и умножим това число с 6!/2! (броят на възможностите за разпределение на гласните), ще получим и броя на думите за този случай.

{:/}

```java
private int countConsonantOptions(int numberOfConsonantPairsInResult, 
		boolean nextPairIsInAscOrder, int numberOfPositions) {
	if (numberOfPositions == 0 && inputOfConsonants.size() == 0) {
		//end of Recursion
		return 1;
	}
	if (inputOfConsonants.size() > numberOfPositions*2) {
		return 0;
	}  
	
	int result = 0;
	Character[] availableConsonants = inputOfConsonants.keySet().toArray(
		new Character[inputOfConsonants.keySet().size()]);
	for(Character nextConsonantChar : availableConsonants) {
		int nextCharOccurrences = inputOfConsonants.get(nextConsonantChar);
		if (nextCharOccurrences == 1) {
			inputOfConsonants.remove(nextConsonantChar);
		} else {
			inputOfConsonants.put(nextConsonantChar, nextCharOccurrences-1);
		}
		
		result += countConsonantOptions(numberOfConsonantPairsInResult, 
			nextPairIsInAscOrder, numberOfPositions-1);
		
		if (numberOfConsonantPairsInResult > 0) {
			Character[] availableConsonantsForPair = inputOfConsonants.keySet().toArray(
				new Character[inputOfConsonants.keySet().size()]);
			for (Character nextConsonantCharForPair : availableConsonantsForPair) {
				if (nextPairIsInAscOrder && 
					letterComparator.compare(nextConsonantChar, nextConsonantCharForPair) >= 0) {
						continue;
				};
				if (!nextPairIsInAscOrder && 
					letterComparator.compare(nextConsonantChar, nextConsonantCharForPair) <= 0) {
						continue;
				};
				int nextCharForPairOccurrences = inputOfConsonants.get(nextConsonantCharForPair);
				if (nextCharForPairOccurrences == 1) {
					inputOfConsonants.remove(nextConsonantCharForPair);
				} else {
					inputOfConsonants.put(nextConsonantCharForPair, nextCharForPairOccurrences-1);
				}
				
				result += countConsonantOptions(numberOfConsonantPairsInResult-1, 
					!nextPairIsInAscOrder, numberOfPositions-1);
  
				// case Consonant S Consonant 
				if (nextConsonantCharForPair == 'S' && numberOfConsonantPairsInResult > 1) {
					Set<Character> availableConsonantsForSecondPair = new HashSet<>(inputOfConsonants.keySet());
					for (Character nextConsonantCharForSecondPair:availableConsonantsForSecondPair) {
						if (!nextPairIsInAscOrder &&
							SAP_LETTER_COMPARATOR.compare(nextConsonantCharForPair, nextConsonantCharForSecondPair) >= 0)  continue;
						if (nextPairIsInAscOrder && 
							SAP_LETTER_COMPARATOR.compare(nextConsonantCharForPair, nextConsonantCharForSecondPair) <= 0)  continue;		
						int occurrencesOfNextCharForSecondPair = inputOfConsonants.get(nextConsonantCharForSecondPair);
						if (occurrencesOfNextCharForSecondPair == 1) {
							inputOfConsonants.remove(nextConsonantCharForSecondPair);
						} else {
							inputOfConsonants.put(nextConsonantCharForSecondPair, occurrencesOfNextCharForSecondPair-1);
						}
						buildResult(numberOfConsonantPairsInResult-2, nextPairIsInAscOrder, numberOfPositions-1);
						//revert the input before we continue 
						inputOfConsonants.put(nextConsonantCharForSecondPair, occurrencesOfNextCharForSecondPair);
					}
				}                               
				inputOfConsonants.put(nextConsonantCharForPair, nextCharForPairOccurrences);
			}
		}
		//revert the input before we continue
		inputOfConsonants.put(nextConsonantChar, nextCharOccurrences);
	}
	return result;
}
```
```java
int resultFor3Pairs = countConsonantOptions(3, true, 7);
System.out.println("Options for the consonants with 3 pairs: " + resultFor3Pairs);
int resultFor4Pairs =  countConsonantOptions(4, true, 6);
resultFor4Pairs *= 2;
System.out.println("Options for the consonants with 4 pairs: " + resultFor4Pairs);
int resultFor5Pairs =  countConsonantOptions(5, true, 5);
System.out.println("Options for the consonants with 5 pairs: " + resultFor5Pairs);

long result = resultFor3Pairs + resultFor4Pairs + resultFor5Pairs;
System.out.println("Overal number of options for the consonants: " + result);
//result = result*6!/2!
result *= 3*4*5*6;
System.out.println("Result: " + result);
```

{::nomarkdown}

<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">
Options for the consonants with 3 pairs: 7993440<br>
Options for the consonants with 4 pairs: 2074500<br>
Options for the consonants with 5 pairs: 132840<br>
Overal number of options for the consonants: 12275280<br>
Result: 4419100800
</div>

<br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week6/SAPTechnoTeaserWordsBruteForce.java" target="_blank">Примерен Java код с Brute-force подход</a>
<br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week6/SAPTechnoTeaserWords.java" target="_blank">Примерен Java код за оптимизирано решение</a>

	</div>
</div>

<hr>
<p>
За произволно естествено число  \( n_0 \), по-голямо от 1, можем да намерим числото \(n_1\) по правилото:<br>
\(  n_{i+1}=\begin{cases} \dfrac{n_i}{2},  \text{ ако } n_i \text{ е четно} \\ 3n_i+1, \text{ ако } n_i  \text{ е нечетно} \end{cases} \)<br>
Ако \(n_1 \ne 1\), намираме \(n_2\) като прилoжим същото правило върху \(n_1\).<br>
Казваме, че \( n_0 \) е на разстояние \( x \) от 1, когато след точно \( x \) прилагания на правилото получаваме за пръв път 1.<br>
Колко естествени числа са на разстояние 61 от 1?
</p>

<div>
	<input type="checkbox" id=solution63><label class="explanationbutton" for=solution63><span>Обяснение</span></label>
	<div class="explanation">
<img style="width: 150px; object-fit: contain; float: right; margin-left: 5px;" src="/technoteaser/docs/images/2019/qFjcXvx-DM4rBer1Uo-8Z1t41tzk0KttJYMqtWMF-dA.png">Задачата, свързана с това правило, е известна под много наименования. Може би най-популярна е като <a href="https://en.wikipedia.org/wiki/Collatz_conjecture" target=_blank>хипотезата на Колац</a>, според която всяко естествено число ще достигне до 1 след карен брой прилагания на правилото.

Най-голямото число, което е на разстояние 61 от 1, е това число, което на всяка стъпка намалява наполовина, т.е. 2<sup>61</sup><br>
Изчисляването на разстоянията на всички числа до 2<sup>61</sup> обаче няма да е ефективно. Вместо това ще се опитаме да изведем правило, което работи в обратна посока, т.е. за дадено \(n\) да намерим числата, които са на разстояние 1 от \(n\). Така ще можем да намерим последователно кои са числата \(N_1\) на разстояние 1 от 1, кои са числата \(N_2\) на разстояние 1 от \(N_1\) и следователно на разстояние 2 от 1 т.н.<br>
До числото \(n_{i+1}\)  можем да достигнем винаги от числото \(n_{i}=2n_{i+1}\), понеже така образуваното \(n_{i}\) е четно.<br>
До числото \(n_{i+1}\)  можем да достигнем от числото \(n_{i}=\dfrac{n_{i+1}-1}{3}\), когато \(n_{i}=\dfrac{n_{i+1}-1}{3}\) е нечетно и ≠ 1 (тъй като при 1 по условие правилото не се прилага).<br>
Получаваме обърнато правило на Колац:<br>
\( N_{i+1} \text{ може да бъде равно на } \begin{cases}  2N_{i} \text{ всеки път }  \\  \dfrac{N_i-1}{3} \text{ , когато } \dfrac{N_i-1}{3} \text{ е цяло, положително, нечетно и} \ne 1  \end{cases}  \)
<br>
\( N_{i+1}  \) e нечетно, когато може да бъде представено като  \( 2k+1  \), т.е. \( N_{i+1} = \dfrac{N_i-1}{3} =2k+1 \iff N_i=6k+4 \) 
<br>
\( N_{i+1} \text{ може да бъде равно на }  \begin{cases}  2N_{i} \text{ всеки път }  \\  \dfrac{N_i-1}{3} \text{ , когато } N_i \text{ &gt; 4 и дава остатък 4 при деление на 6} \end{cases}  \) <br>
Обърнатото правило не е функция, понеже приложено върху естествените числа, които дават остатък 4 при деление на 6, връща повече от един резултат.
Затова математически правилното изписване на релацията изглежда така:<br>
\(  R(n) =  \begin{cases} \{2n\}  \text{, когато } n \equiv 0,1,2,3,5 \text{ (mod 6) } \\   \{2n, \dfrac{n-1}{3}\}  \text{, когато } n \equiv 4 \text{ (mod 6) }  \end{cases} \)
<br>
Това ни навежда на въпроса може ли да изведем едно число по два различни начина, т.е. използвайки този алгоритъм да преброим едно и също число повече от веднъж?<br>
Тъй като и двете правила дефинират един и същи граф, но с обърната посока на връзките между числата, а оригиналното правило дефинира един единствен път на дадено число (евентуално към 1), то това ни гарантира и един единствен път в обратна посока от 1 към даденото число (ако такъв съществува). <br>
Граф или дърво? Всъщност това е без значение. Дори и да не ползваме хипотезата на Колац, която макар и недоказана, е потвърдена за числата, с които работим, правилото на Колац ни гарантира, че ако достигнем 1, то процесът спира и сме намерили еднозначно пътя и дължините на всички числа, през които сме минали. В противен случай или сме достигнали до цикъл, или получаваме разходяща редица, но и в двата случая ще става дума за числа, от които не се интересуваме, тъй като те няма да са на крайно разстояние от 1.<br>
Остана да преброим числата на разстояние 61 от 1, за което елементарна имплементация с рекурсия върши достатъчно добра работа:

{:/}

```java
private int getCollatzNumbersCount(long fromNumber, int atDistance) {
         if (atDistance == 0) {
                  return 1;
         }
         int res = getCollatzNumbersCount(fromNumber * 2, atDistance - 1);
         if (fromNumber > 4 && fromNumber % 6 == 4) { 
                 res += getCollatzNumbersCount((fromNumber - 1) / 3, atDistance - 1);
         }
         return res;
}
```
```java
System.out.println(getCollatzNumbersCount(1, 61));
```

{::nomarkdown}

<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">1040490</div>
<hr>
Можем ли да предположим, че хипотезата на Колац е вярна, тъй като е потвърдена за всички числа до 87∗10<sup>60</sup>?<br>
Всъщност в математиката са известни доста "подвеждащи" примери, в които дадено твърдение изглежда вярно, понеже е проверено до на пръв поглед големи числа. Например най-големият общ делител на числата \( n^{17}+9 \) и \( (n+1)^{17}+9 \) e 1 за на пръв поглед всички естествени числа \( n \). Дори да напишем програма, която започва от \( n=1 \) и проверява последователно всички следващите числа, един персонален компютър и един човешки живот няма да са ни достатъчни, за да намерим друг резултат. Причината за това е, че правилото се нарушава за пръв път при \( n=8424432925592889329288197322308900672459420460792433\).
А когато говорим за математика, не трябва да забравяме, че всяко крайно число, колкото и голямо да е то, е пренебрежимо малко на фона на безкрайно многото оставащи по-големи от него числа.<br>
<br>
Хипотезата на Колац е известна и като най-лесната (за разбиране) недоказана все още хипотеза в математиката. Може би това е и една от причините да бъде давана често за пример. Има и различни парични награди за доказателство, потвърждаващо или оборващо хипотезата, достигащи до £1000.<br>
Mатематическите задачи на хилядолетието, всички без една все още нерешени и носещи награди от по 1 милион долара всяка\, можете да намерите <a href="http://www.claymath.org/millennium-problems" target=_blank>тук</a>.

<br><br>			
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/week6/CollatzNumbersOnDistance.java" target="_blank">Примерен Java код</a>
	</div>
</div>
</div>

<input type="checkbox" id=game2Toggle>
<label for=game2Toggle class="week">
<h1 id="game2"> SAP Техноблъсканица 2019 специално издание <span></span></h1>
</label>	
<div>
<p>За извършено нарушение подозират Ангел, Борис, Васил и Георги.<br>
<ul>
<li>Ангел твърди, че нарушението е извършено от Борис;</li>
<li>Борис твърди, че нарушението е извършено от Георги;</li>
<li>Васил казва, че той не е извършил нарушението;</li>
<li>Георги също казва, че той не е извършил това нарушение.</li>
</ul>
Нарушителят е само един. Кой е той, ако знаем, че трима са се уговорили да излъжат, а един е казал истината?
<ul class="answersWithRadio">
	<li> Ангел</li>
	<li> Борис</li>
	<li> Васил</li>
	<li> Георги</li>
</ul></p>
<div>
	<input type="checkbox" id=game2solution1><label class="explanationbutton" for=game2solution1><span>Обяснение</span></label>
	<div class="explanation">
Тъй като имаме само 4 възможности за това кой може да е нарушителят, можем да ги проверим последователно:
<ul>
<li>Ако предположим, че нарушителят е Ангел, то тогава Васил и Георги ще са казали истината, което не е възможно по условие.</li>
<li>Ако предположим, че нарушителят е Борис, то тогава Ангел, Васил и Георги ще са казали истината, което отново не в възможно.</li>
<li>Ако предположим, че нарушителят е Васил, то тогава само Георги е казал истината и това е възможно решение на задачата.</li>
<li>Ако предположим, че нарушителят е Георги, то тогава Борис и Георги ще са казали истината, а това отново не е възможно.</li>
</ul>
Получихме единствена възможност за нарушителя и той е <b>Васил</b>.
	
	</div>
</div>

<hr>
<p>Коя е последната цифра на числото <nobr>2<sup>2019</sup> ?</nobr></p>
<div>
	<input type="checkbox" id=game2solution2><label class="explanationbutton" for=game2solution2><span>Обяснение</span></label>
	<div class="explanation">
Ако не знаем откъде да започнем, можем да разгледаме последната цифра на 2<sup>n</sup> за няколко последователни стойности на n, започвайки от 1.
<table>
<tr><td>2<sup>1</sup> = </td><td align=right> <font color="darkred">2</font></tr>
<tr><td>2<sup>2</sup> = </td><td align=right> <font color="darkred">4</font></tr>
<tr><td>2<sup>3</sup> = </td><td align=right> <font color="darkred">8</font></tr>
<tr><td>2<sup>4</sup> = </td><td align=right> 1<font color="darkred">6</font></tr>
<tr><td>2<sup>5</sup> = </td><td align=right> 3<font color="darkred">2</font></tr>
<tr><td>2<sup>6</sup> = </td><td align=right> 6<font color="darkred">4</font></tr>
<tr><td>2<sup>7</sup> = </td><td align=right> 12<font color="darkred">8</font></tr>
<tr><td>2<sup>8</sup> = </td><td align=right> 25<font color="darkred">6</font></tr>
</table>
Последната цифра на 2<sup>n+1</sup> зависи само и единствено от последната цифра на 2<sup>n</sup>, т.е. можем да сме сигурни, че след първото повторение на последната цифра (в този случай това е цифрата 2 при n = 5) ще имаме повтаряща се последователност на последните цифри (2,4,8 и 6).<br>
Тъй като 2019 = 504*4 + 3, то последната цифра на 2<sup>2019</sup> e равна на последната цифра на 2<sup>3</sup>, т.е. <nobr><b>това е цифрата 8.</b></nobr>	
	</div>
</div>

<hr>
<p>Разполагаме с общо 9 яйца, надписани с цифрите от 1 до 9, така че да можем да ги различаваме едно от друго.<br>
Осем от яйцата са еднакви, а едно е с различно тегло, като не знаем дали е по-тежко или по-леко.<br>
Като използваме везна, която показва от коя страна сме поставили по-голямо тегло или пък че от двете страни теглото е еднакво, какъв е най-малкият брой измервания, с който можем да сме сигурни, че ще намерим яйцето с различно тегло (вкл. при най-лошия за нас случай)?</p>
<div>
	<input type="checkbox" id=game2solution3><label class="explanationbutton" for=game2solution3><span>Обяснение</span></label>
	<div class="explanation">
<ul>
<li>Първо премерваме по 3 яйца на везната, например (1,2,3) спрямо (4,5,6)</li>
<li>Ако те са с еднакво тегло, тогава попадаме в по-лесния случай - различното яйце е измежду 7, 8 и 9, т.е. достатъчно е да премерим 7 и 8, както и 7 и 9, за да определим еднозначно кое е различното яйце</li>

<li>Ако (1,2,3) и (4,5,6) са с различно тегло, можем да продължим като сравним теглото на (1,2,3) спрямо теглото на (7,8,9). По този начин ще опредеим коя тройка яйца съдържа различното яйце и дали различното яйце е по-тежко или по-леко. Това ще ни позволи да направим финално трето измерване, сравнявайки теглата на две яйца, взети от групата, за която знаем, че съдържа различното яйце. </li>
<b>Отговор: 3</b>
<ul>
	</div>
</div>

<hr>
<p>В кои от случаите може да се състави валиден аритметичен израз от лявата страна на равенството, така че то да е изпълнено, ако:<br>
<ul>
<li>Не можем да добавяме други числа освен дадените;</li>
<li>Можем да ползваме следните аритметични операции неограничен брой пъти: 
   <ul>
        <li>Бинарни (двуаргументни): събиране (+), изваждане (-), умножение (*), деление (/);</li>
        <li>Унарни (едноаргументни) : факториел (!), квадратен корен (√);</li>
    </ul>
</li>
<li>Можем да ползваме скоби ( ) за промяна на стандартната последователност на изпълнение на операциите;</li>
<li>Не можем да образуваме многоцифрени числа в артиметичния израз като не слагаме операция между две съседни числа.</li>
</ul>
Пример: равенството 0 0 0 = 6  може да бъде изпълнено чрез следния аритметичен израз: \( (0! + 0! + 0!)! \) тъй като \( (0! + 0! + 0!)! = (1+1+1)! = 3! = 6 \) 
<ul class="answersWithCheckbox">
	<li> 0  0  0 = 24</li>
	<li> 1  1  1 = 25</li>
	<li> 2  2  2 = 26</li>
	<li> 3  3  3 = 27</li>
	<li> 4  4  4 = 28</li>
	<li> 5  5  5 = 29</li>
	<li> 6  6  6 = 30</li>
	<li> 7  7  7 = 31</li>
	<li> 8  8  8 = 32</li>
	<li> 9  9  9 = 33</li>
</ul></p>
<div>
	<input type="checkbox" id=game2solution4><label class="explanationbutton" for=game2solution4><span>Обяснение</span></label>
	<div class="explanation">
<ul class="answersWithCheckbox">
<li class="notCorrectAnswer" style="color:darkred">  0  0  0 = 24 </li>
<li class="notCorrectAnswer" style="color:darkred"> 1  1  1 = 25 </li>
<li class="correctAnswer" style="color:darkgreen">  2  2  2 = 26 <font color=black>→ \( (2+2)! + 2 = 4! + 2 = 26 \)</font></li>
<li class="correctAnswer" style="color:darkgreen"> 3  3  3 = 27 <font color=black>→ \( 3*3*3 = 27\) </font></li>
<li class="correctAnswer" style="color:darkgreen"> 4  4  4 = 28 <font color=black>→ \( 4! + \sqrt{4} + \sqrt{4} = 24+2+2 = 28\) </font></li>
<li class="correctAnswer" style="color:darkgreen"> 5  5  5 = 29 <font color=black>→ \( 5!/5 + 5 = 4!+5 = 24+5 = 29\) </font></li>
<li class="correctAnswer" style="color:darkgreen"> 6  6  6 = 30 <font color=black>→ \( 6*6 - 6 = 5*6 = 30\) </font></li>
<li class="notCorrectAnswer" style="color:darkred"> 7  7  7 = 31 </li>
<li class="correctAnswer" style="color:darkgreen"> 8  8  8 = 32 <font color=black>→ \( (\sqrt{8+8})!+8 = 4!+8 = 24+8 = 32 \) </font></li>
<li class="correctAnswer" style="color:darkgreen"> 9  9  9 = 33 <font color=black>→ \( \sqrt{9} * 9 +  (\sqrt{9})! = 3*9 + 3! = 27+6 = 33\) </font></li>
</ul>

Защо не можем да съставим аритметичен израз за 0  0  0 = 24 ?<br>
Единствената операция, която превръща нулата в нещо различно от нула е факториел (0! = 1).<br>
Разполагайки с една, две или три единици можем да изключим операциите умножение и деление като не особено полезни.<br>
Тъй като 2!=2, а 3!=6, а 6! е твърде голямо число, което не е точен квадрат (т.е. няма как да ползваме операцията за квадратен корен за да се върнем евентуално към 24), числото 24 остава недостижимо. <br>
Разсъжденията са аналогични за 1 1 1 = 25<br>
<br>
Защо не можем да съставим аритметичен израз за 7  7  7 = 31?<br>
31 е просто число => последната по ред на изчисления аритметична операция, с която можем да достигнем до 31, може да бъде събиране, изваждане, деление или корен квадратен.
<ul>
<li>Събиране: Едно от събираемите задължително трябва да бъде 7, тъй като унарната операция 7! дава твърде голямо число, а другата унарна операция  √7 (вкл. приложена върху 7!) дава ирационално число. 
Това означава, че другото събираемо трябва да бъде равно на 24 и трябва да го получим с останалите две седмици. Тъй като 7+7=14, а 7*7=49, а както вече споменахме факториелът дава твърде голямо число, а квадратния корен или ирационално, или √(7*7)=7, то числото 24 не е достижимо с аритметичен израз, съставен от две седмици.</li>
<li>Изваждане: умаляемото трябва да бъде равно на 38 а умалителят на 7 (38 – 7 = 31), т.е. търсим аритметичен израз с две седмици, равен на 38,  което е невъзможно, подобно на разсъжденията по-горе</li>
<li>Деление: делимото трябва да бъде равно на 31*7, а делителят на 7 (217/7 = 31), т.е. търсим аритметичен израз с две седмици, равен на 217, което отново е невъзможно (7!/7=6!=720) </li>
<li>Корен квадратен: търсим израз от вида 7 7 7 = 31<sup>2</sup> = 961. Тъй като 7!=5040, а 6!=720, сравнително лесно се проверява, че до 961 не можем да достигнем.</li>
</ul>		
	</div>
</div>

<hr>
<p>Aкo \( a \), \( b \), \( c \) и \( d \) са естествени числа (не непременно различни), такива, че тяхната сума е равна на 2019, то каква е най-голямата възможна стойност на \( ab + bc + cd \)?</p>
<div>	
	<input type="checkbox" id=game2solution5><label class="explanationbutton" for=game2solution5><span>Обяснение</span></label>
	<div class="explanation">

<h3 id="game2,game2solution5,Решение_на_програмиста">Решението на програмиста:</h3>
Тъй като 2019 не е твърде голямо число, можем да си позволим <a href="https://en.wikipedia.org/wiki/Brute-force_search" target=_blank>Brute-force</a> подход.<br>
За да генерираме всички възможни стойности на \( a \), \( b \), \( c \) и \( d \)  е достатъчно да напишем една фукция, която генерира всички двойки числа, чиято сума е равна на подаден параметър. За работа с двойки числа ще ползваме класа <a href="https://commons.apache.org/proper/commons-lang/apidocs/index.html?org/apache/commons/lang3/tuple/ImmutablePair.html" target=_blank>ImmutablePair</a> от Apache Commons Lang библиотеката.

{:/}

```java
List <ImmutablePair<Integer,Integer>> generatePairs(int withSum) {
	ArrayList<ImmutablePair<Integer,Integer>> result = new ArrayList<>();
	for (int i=1; i < withSum; i++) {
		result.add(new ImmutablePair<>(i, withSum - i));
	}	
	return result;		
}
```

```java
private static final int SUM = 2019;
```

```java
int maxSumOfProducts = 0;

for (ImmutablePair<Integer, Integer> pair1 : generatePairs(SUM)) {
	Integer a = pair1.left;
	for (ImmutablePair<Integer, Integer> pair2 : generatePairs(SUM - a)) {
		Integer b = pair2.left;
		for (ImmutablePair<Integer, Integer> pair3 : generatePairs(SUM - a - b)) {
			Integer c = pair3.left;
			Integer d = pair3.right;
			int product = a*b + b*c + c*d;
			if (product > maxSumOfProducts) {
				maxSumOfProducts = product;
			}
		}
	}
}
System.out.println(maxSumOfProducts);
```

{::nomarkdown}

<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">1019089</div>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2019/specialedition/MaxSumOfProducts.java" target=_blank>Примерен Java код</a><br>
<h3 id="game2,game2solution5,Решение_на_математика">Решението на математика:</h3>
<img style="max-width: 250px; object-fit: contain; float:right;" src="/technoteaser/docs/images/2019/5FwROhTk4DZEFI8DgX8mGqTRYhyg3Yfplqe4EhyxjXU.jfif">
Вариант на тази задача (с условие \(a+b+c+d=63\)) е дадена на олимпиада по математика в Австралия през 2013 г. за ученици.
Разбира се учениците не могат да ползват математически анализ, а задачата има по-лесно решение.<br>
Нека конструираме 3 правоъгълника, които имат лица съответно \( ab \), \( bc \) и \( cd \), както е показано на графиката.<br>
\( ab + bc + cd = (a + c)(b + d) – ad \) <br>
Интересуваме се от сумата на лицата на сините правоъгълници.
Важно е да забележим, че можем да минимизираме лицето на сивия (излишния) правоъгълник със страни \(a\) и \(d\), без да ограничаваме с това страните (и лицето)  на големия правоъгълник със страни \(a+c\) и \(b+d\), тъй като дори и с фиксирани a и d все още нямаме ограничения за b и c. T.e. всичко, което трябва да направим, е да намерим стойностите на \( a \), \( b \), \( c \) и \( d \), за които имаме минимално лице за сивия правоъгълник и максимално голямо лице за големия правоъгълник.<br>
Разбира се  \(min (ad) = 1 \) при \(а=1\) и \(d=1\), при което получаваме \(b + c = 2017\) <br>
От друга страна лицето на големия правоъгълник ще бъде най-голямо, когато той най-силно се доближава до квадрат. Страните на идеален квадрат ще бъдат равни, т.е. \(a+c=b+d=2019/2=1009.5\). Най-близкото приближение в цели числа е при страни 1009 и 1010 и съответно \(b\) и \(c\) ще споделят тези две стойности.<br>
Ако този факт за най-голямо лице на правоъгълник (с фиксиран периметър) не ни е известен, можем да продължим решението на задачата с уравнение.<br>
Знаем, че \( c = 2017 - b \)<br>
Търсим максимума на \( ab + bc + cd = \) \( 1b + b(2017-b) + (2017-b)1 = \) \( b + 2017b – b^2 + 2017 – 2017b =\) \( -b^2 + 2017b + 2017\) <br>
Фукцията \( \alpha x^2 + \beta x + \gamma \) достига своя максимум или минимум при \( x=  \dfrac {- \beta}{2 \alpha}  \) <br>
В нашия случай \( \alpha = -1 &lt; 0 \), т.е. имаме максимум при \( x=2017/2=1008.5 \) <br>
Отново взимаме най-близките до 1008.5 цели числа, като получаваме еквивалентен резултат при \(b=1008, c=1009 \) и при \(b=1009, c=1008\) <br>
Максималната стойност на \( ab + bc + cd = 1*1008 + 1008*1009 + 1009*1 = 1019089\) <br>
<b>Отговор: 1019089</b>

	</div>
</div>
</div>

<script>
function hashChange() {
	if (window.location.hash) {
		var hashID = window.location.hash.substr(1);
	        var hashArr = hashID.split(",");
	        for (i in hashArr) {
			var obj = document.getElementById(hashArr[i] + (i==0 ? "Toggle" : ""));
			if (obj) {obj.checked = true;}
		}
	}
}
window.onhashchange = hashChange;
hashChange();
</script>
<br>
<div class="footer">
<a href="https://www.sap.com/about/careers/who-we-are/locations/sap-labs-bulgaria.html" target="_blank"><p class="footer-element">Виж повече за развойния център на SAP в София</p></a><a href="https://www.sap.com/about/careers/who-we-are/locations/sap-labs-bulgaria.html" target="_blank"><img class="footer-image" src="/technoteaser/docs/images/sap_logo.png" width="40" height="20"></a> <a href="https://www.facebook.com/saplabsbg" target="_blank"><p class="footer-element">Харесай страницата ни във Facebook</p></a><a href="https://www.facebook.com/saplabsbg" target="_blank"><img class="footer-image" src="/technoteaser/docs/images/fb_logo.png" width="30" height="20"></a> <a href="https://jobs.sap.com/search/?q=&locationsearch=bulgaria" target="_blank"><p class="footer-element">Разгледай отворените позиции при нас</p></a><a href="https://jobs.sap.com/search/?q=&locationsearch=bulgaria" target="_blank"><img class="footer-image" src="/technoteaser/docs/images/network.png" width="25" height="25"></a>
</div>

{:/}

