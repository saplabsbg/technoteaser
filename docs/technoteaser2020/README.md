# SAP Техноблъсканица 2020

{::nomarkdown}
<div style="display:none"><img src="/technoteaser/docs/images/sharePicture.png"></div>
<link rel="stylesheet" href="../styles/technoteaser.css">
<link rel="stylesheet" href="../styles/footer.css">
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

<input type="checkbox" id=week1Toggle>
<label for=week1Toggle class="week">
<h2 id=week1>Седмица №1 <span></span></h2>
</label>	
<div>
<h3 id="week1,question1">Най-доброто лекарство</h3>
<p>При проучвания на лечението на рядко заболяване са направени независими едно от друго изпитания на 2 лекарства (лекарство А и лекарство Б).
Всеки доброволец е трябвало да взема едно от лекарствата в продължение на една седмица, за да се установи дали то е ефикасно, или не.<br>Проучванията продължили 2 седмици.
През първата седмица лекарство А е било ефикасно и е излекувало 63 души от общо 90 доброволци (което прави 70% от участвалите). Лекарство Б е било ефикасно при 8 от общо 10 доброволци (80% от участвалите).
През втората седмица лекарство А е било ефикасно при 4 от 10 доброволци (или 40% от участвалите), а лекарство Б е било ефикасно при 45 от 90 доброволци (или 50% от участвалите).

<table style="border-collapse: collapse; margin-top: 10px; margin-bottom: 10px; font-weight: bold; ">
	<tr style="background-color: LightGray;">
		<td style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">Седмица</td><td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">Лекарство A</td><td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">Лекарство Б</td>
	</tr>
	<tr>
		<td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">Седмица 1</td><td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">\( \dfrac{63}{90}=70 \% \)</td><td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">\( \dfrac{8}{10}=80 \% \)</td>
	</tr>
	<tr>
		<td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">Седмица 2</td><td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">\( \dfrac{4}{10}=40 \% \)</td><td align=center style="padding-left: 5px; padding-right: 5px; padding-top: 5px; padding-bottom: 5px;">\( \dfrac{45}{90}=50 \% \)</td>
	</tr>
</table>

Кое лекарство е по-ефикасно?

<ul class="answersWithRadio">
	<li> Лекарство А е по-ефикасно</li>
	<li> Лекарство Б е по-ефикасно</li>
	<li> Двете лекарства са еднакво добри</li>
</ul>
</p>
<div>
	<input type="checkbox" id=solution11><label class="explanationbutton" for=solution11><span>Обяснение</span></label>
	<div class="explanation">
Гледайки само процентите, на пръв поглед изглежда, че лекарство А е по-неефикасно от лекарство Б (70% и 40% спрямо 80% и 50%).<br>
Въпреки това, една реална проверка на данните изисква пресмятане на крайния процент положително повлияли се хора спрямо всички участвали в изпитанията на конкретното лекарство. В случая доброволците при проучванията и на двете лекарства са точно 100 и е достатъчно да проверим кое лекарство е помогнало на повече (като брой) хора. Лекарство А е помогнало на 63 + 4 = 67 човека (или 67% от всички участвали), а лекарство Б е помогнало на 8 + 45 = 53 човека (или 53% от участвалите), <b>което прави лекарство А по-ефикасно</b>.<br><br>
Защо не можем да вземем средното аритметично на процентните резултати от двете седмици, например за лекарство А (70+40)/2=55%, а за лекарство Б (80+50)/2=65% ?<br>
Причината е във факта, че резултатите от двете седмици имат различна тежест, която зависи от броя доброволци, участвали през тази седмица.
<hr>
Този противоречив и дори заблуждаващ начин на представяне на данните е добре познат в статистиката под името <a href="https://en.wikipedia.org/wiki/Simpson%27s_paradox" target=_blank> Парадокс на Симпсън</a>. Известни са и немалко примери от реалния живот, като например добилият популярност през далечната 1973 г. случай на несъществуваща <a href="https://medium.com/@dexter.shawn/how-uc-berkeley-almost-got-sued-because-of-lying-data-aaa5d641f571" target=_blank> полова дискриминация в Калифорнийския университет, Бъркли</a>, провокиран от недобре интерпретирана информация.<br>

	</div> 
</div>
<h3 id="week1,question2">Здрависване с 9 човека</h3>
<p>На първата мениджърска среща след COVID-19 пандемията присъстват на място в стаята 27 човека. <br>
Възможно ли е всеки в стаята да се здрависа с точно 9 човека?<br>
Разбира се, други хора не участват <img src="/technoteaser/docs/images/2020/XM8dNAdgLdQLXr82FT-8KNvS3JdX4Sg3XOnI5C9bj64.png" width="20px" alt="Усмивка" title="Усмивка">, закъснели няма <img src="/technoteaser/docs/images/2020/MgD-x1EIDmjmllRROG9xvGp9I34YL-vXULekz3nmBe4.png" width="20px" alt="Онемял" title="Онемял"> и всички са все още в добро психично здраве, т.е. никой не се здрависва сам със себе си <img src="/technoteaser/docs/images/2020/hCbLs0jTqHI9jYS92iQ7u1lSkHzoztPJEyuXGFiuVA8.png" width="20px" alt="Изчервяване" title="Изчервяване"></p>
<div>
	<input type="checkbox" id=solution12><label class="explanationbutton" for=solution12><span>Обяснение</span></label>
	<div class="explanation">
Нека предположим, че всеки в стаята се е здрависал с 9 човека и се опитаме да преброим общия брой здрависвания. В едно здрависване участват двама човека, т.е. здрависванията са равни на \( 27*9/2 = 121.5 \), което не е цяло число, откъдето следва, че предположението ни е грешно. Следователно <b>не е възможно в стая с 27 човека всеки да се е здрависал с 9 човека.</b>
	</div> 
</div>

<h3 id="week1,question3">Здрависване с х човека</h3>
<p>Все още обсъждаме мениджърската среща <img src="/technoteaser/docs/images/2020/FHKYiDwH8gHO-gAYwsykDJPznhss7NBYoMCgWl6MPuc.png" width="20px" alt="Изчервяване" title="Изчервяване">!<br>
В стаята все още има 27 човека.<br>
Ако всеки се е здрависал с еднакъв брой хора, колко най-много може да е той, ако знаем, че не се е здрависал всеки с всеки?</p>
<div>
	<input type="checkbox" id=solution13><label class="explanationbutton" for=solution13><span>Обяснение</span></label>
	<div class="explanation">
От решението на предишната задача вече знаем, че в стаята всеки може да се здрависа с четен (еднакъв) брой хора. Ако всеки се здрависа с 26 човека, това ще означава здрависване всеки с всеки. Следващата възможност е всеки да се здрависа с 24 човека (всички останали без двама). За да проверим, че това е възможно, нека помислим за съответстващо правило за здрависване. Понеже здрависванията са много, всъщност, ще бъде по-лесно да помислим за правило, по което двама души не се здрависват.<br>
Ако подредим хората в кръг, тогава всеки ще има по двама съседи (отляво и отдясно по един) и това би било удобно условие за не-здрависване.<br>
Ако обозначим мениджърите в стаята с m<sub>1</sub>, m<sub>2</sub>, ... , m<sub>27</sub>, чисто математически това правило можем да запишем като:
<ul>
    	<li>m<sub>1</sub> не се здрависва с m<sub>27</sub> и m<sub>2</sub></li>
    	<li>m<sub>i</sub> не се здрависва с m<sub>i-1</sub> и m<sub>i+1</sub>, за i ∈ (1, 27)</li>
    	<li>m<sub>27</sub> не се здрависва с m<sub>26</sub> и m<sub>1</sub></li>
</ul>
Отговор: <b>всеки може да се е здрависал най-много с 24 човека.</b>
	</div> 
</div>
</div>
<!-- end of week 1-->
<input type="checkbox" id=week2Toggle>
<label for=week2Toggle class="week">
<h2 id=week2>Седмица №2 <span></span></h2>
</label>
<div>
<h3 id="week2,question1">Тенис на маса</h3>
<p>Асен, Борис и Влади играли тенис на маса. Във всяка игра участвали двама от тях, а третият си почивал. В следващата игра участвали победителят от текущата игра и почивалият си. След като приключили с игрите се оказало, че Асен е играл в 8 игри, Борис - в 11, а Влади - в 15.<br>Кой е загубил четвъртата игра?</p>
<div>
	<input type="checkbox" id=solution21><label class="explanationbutton" for=solution21><span>Обяснение</span></label>
	<div class="explanation">
От информацията, с която разполагаме, можем да пресметнем общо колко игри са били изиграни. Тъй като във всяка игра участват по двама, броят на игрите е \( (8+11+15)/2 = 17 \).<br>
Ако играч участва в първата игра и губи във всяка своя игра, ще вземе участие в нечетните игри (1,3,5,7,9,11,13,15,17), т.е. в 9 игри.<br>
Ако играч участва във втората игра и губи във всяка своя игра, ще вземе участие в четните игри (2,4,6,8,10,12,14,16), т.е. в 8 игри.<br>
Tъй като участие в 8 игри е теоретичният минимум, то можем да сме сигурни, че Асен е взел участие във втората (и всички четни) игри и е загубил във всички тях, което означава и че <b>Асен е загубил четвъртата игра</b>.
	</div>
</div>
<h3 id="week2,question2">Наследството</h3>
<p>Баща завещал парите си на своите деца по следното правило:<br>
<ol>
	<li>Най-голямото дете получава 1000 лв. и една десета от останалите пари;</li>
	<li>Второто по големина дете (ако го има), получава 2000 лв. и една десета от останалите към този момент пари;</li>
	<li>Третото по големина дете (ако го има), получава 3000 лв. и една десета от новия остатък;</li>
	<li style="list-style-type: none;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... </li>
	<li style="list-style-type: none;"> n-тото по големина дете (ако го има), получава n*1000 лв. и една десета от останалите към този момент пари.</li>
</ol>
Оказало се, че парите били раздадени без остатък и всяко дете получило една и съща сума пари.<br>
Колко най-много на брой деца е имал бащата?</p>
<div>
	<input type="checkbox" id=solution22><label class="explanationbutton" for=solution22><span>Обяснение</span></label>
	<div class="explanation">
Задачата има едно тривиално решение, когато бащата има 1 дете и 1000 лв., които му дава по така дефинираното правило.<br>
Как проверяваме за други решения?<br>
Нека бащата е имал в началото \( x \) лв. и повече от едно дете.<br>
Тогава първото дете ще получи \( а_1=1000 + \dfrac{1}{10}(x-1000) \) лева,<br>
а второто дете ще получи \( а_2 = 2000 + \dfrac{1}{10}(x-2000-а_1) \) лева.<br>
Понеже \( а_1 = а_2 \) , получаваме следното уравнение:<br>
\( 1000 + \dfrac{1}{10}(x-1000) =  2000 + \dfrac{1}{10}(x-2000 - (1000 + \dfrac{1}{10}(x-1000))) \iff \)<br>
\( x-1000 =  10000 + x-2000 - 1000 - \dfrac{1}{10}(x-1000) \iff \)<br> 
\( \dfrac{1}{10}(x-1000) = 8000 \iff \)<br> 
\( x-1000 = 80000 \iff \)<br> 
\( x = 81000 \)<br> 
Тъй като така съставеното уравнение ни гарантира само факта, че първото и второто по възраст деца получават една и съща сума пари, трябва да проверим какво биха получили останалите:
<ol>
	<li>Първото дете получава \( 1000 + \dfrac{1}{10}(81000-1000) = 1000+8000=9000\) лв., като остават 72000 лв.</li>
	<li>Второто дете получава \( 2000 + \dfrac{1}{10}(72000-2000) = 2000+7000=9000\) лв., като остават 63000 лв.</li>
	<li>Третото дете получава \( 3000 + \dfrac{1}{10}(63000-3000) = 3000+6000=9000\) лв., като остават 54000 лв.</li>
	<li>Четвъртото дете получава \( 4000 + \dfrac{1}{10}(54000-4000) = 4000+5000=9000\) лв., като остават 45000 лв.</li>
	<li>Петото дете получава \( 5000 + \dfrac{1}{10}(45000-5000) = 5000+4000=9000\) лв., като остават 36000 лв.</li>
	<li>Шестото дете получава \( 6000 + \dfrac{1}{10}(36000-6000) = 6000+3000=9000\) лв., като остават 27000 лв.</li>
	<li>Седмото дете получава \( 7000 + \dfrac{1}{10}(27000-7000) = 7000+2000=9000\) лв., като остават 18000 лв.</li>
	<li>Осмото дете получава \( 8000 + \dfrac{1}{10}(18000-8000) = 8000+1000=9000\) лв., като остават 9000 лв.</li>
	<li>Деветото дете получава \( 9000 + \dfrac{1}{10}(9000-9000) = 9000+0=9000\) лв., като не остават повече пари.</li>
</ol>
Следователно <b>бащата е имал най-много 9 деца.</b>
	</div>
</div>
<h3 id="week2,question3">4 камъка и везна</h3> 
<p>Разполагаме с 4 камъка с различен цвят. Знаем, че един от тях тежи 1 грам, един тежи 2 грама, един тежи 3 грама и един тежи 4 грама, но не знаем конкретно кой камък колко тежи. Разполагаме и с везна, която показва от коя страна сме поставили по-голяма тежест или че от двете страни сме поставили едно и също тегло, но не и колко конкретно е теглото на някоя от страните.<img width=150px src="/technoteaser/docs/images/2020/ooyehJUtILEihlXxb3KC2H_G7t5SWodhbEiBhrAb_iM.png" style="float: right;"> Можем да поставяме прозволен брой камъни на всяка страна на везната.<br>
С колко най-малко претегляния можем да определим теглото на всеки камък (вкл. при най-лошия за нас сценарий, т.е. без да разчитаме на късмет)?</p>
<div>
	<input type="checkbox" id=solution23><label class="explanationbutton" for=solution23><span>Обяснение</span></label>
	<div class="explanation">
Нека обозначим камъните с <font color="darkred">A</font>, <font color="darkred">B</font>, <font color="darkred">C</font> и <font color="darkred">D</font>.Всеки от тях може да участва в точно 3 двойки. Например за камъка <font color="darkred">A</font> това са (<font color="darkred">A</font>, <font color="darkred">B</font>), (<font color="darkred">A</font>, <font color="darkred">C</font>) и (<font color="darkred">A</font>, <font color="darkred">D</font>). На всяка двойка камъни можем да съпоставим останалите два камъка:
<ul>
	<li>(<font color="darkred">A</font>, <font color="darkred">B</font>)  -  (<font color="darkred">C</font>, <font color="darkred">D</font>)</li>
	<li>(<font color="darkred">A</font>, <font color="darkred">C</font>)  -  (<font color="darkred">B</font>, <font color="darkred">D</font>)</li>
	<li>(<font color="darkred">A</font>, <font color="darkred">D</font>)  -  (<font color="darkred">B</font>, <font color="darkred">C</font>)</li>
</ul>
Ако това са три последователни претегляния, след тях ще сме в състояние да кажем кой е най-тежкият камък (с тегло 4 грама) и кой е най-лекият (с тегло 1 грам), понеже:<br>
- Везната ще покаже равно тегло само при едно от тези претегляния и това е случаят, когато от двете страни има тегло от 5 грама (2 + 3 = 1 + 4);<br>
- Най-тежкият камък ще бъде винаги от по-тежката страна в останалите 2 претегляния, с което го определяме еднозначно;<br>
- Най-лекият камък ще бъде винаги от по-леката страна в останалите 2 претегляния, с което също го определяме еднозначно.<br>
Така с четвърто претегляне на останалите два камъка ще определим кой от тях е по-тежък (и съответно тежи 3 грама) и кой по-лек (и е 2 грама).<br><br>

Можем ли да решим задачата с по-малко на брой претегляния?<br>
Всяко претегляне има 3 възможни резултата (лявата страна е по-тежка, равна или по-лека на дясната). Това означава, че едно претегляне ни дава най-много \( \log _{2} 3 \) бита информация.<br>
Имаме \( 4!=24 \) възможни конфигурации за камъните, т.е.  \( \log _{2} 24 \) бита възможости.<br>
Ако имаме нужда от \( n \) претегляния, с които можем да определим еднозначно теглата на камъните, то със сигурност  \( n * \log _{2} 3  \ge \log _{2} 24 \iff \)  \( n  \ge \dfrac{\log _{2} 24}{ \log _{2} 3 } \iff \) \( n  \ge \log _{3} 24 \iff \) \( n  \ge 2.89 \implies \) \( n  \ge 3 \)<br>
Тогава можем ли да решим задачата с 3 претегляния?<br>
Отговорът е отрицателен и за да го покажем, ще трябва да разгледаме по-подробно възможните конфигурации за първо претегляне, които са:<br>
- 1:1 (един камък спрямо един камък).<br>В този случай везната не може да бъде балансирана, а от двата възможни резултата от измерването получаваме точно 1 бит информация. Тъй като теоретичният максимум от останалите 2 измервания е \( 2\log_2 3 \), а \( 1 + 2\log_2 3 \lt log_2 24 \), то нямаме шанс да определим теглото на камъните в общия случай.<br>
- 1:2 (един камък спрямо два камъка).<br>
Имаме 4 конфигурации, при които везната ще е балансирана: (1 + 2 = 3), (2 + 1 = 3), (1 + 3 = 4) и (3 + 1 = 4)<br>
Останалите 20 конфигурации се разпределят за случаите, при които везната няма да е балансирана. Дори и те да са разпределени по равно (което по принцип не е така), т.е. 10 за случая двойката камъни да е по-лека от камъка от другата страна и 10 за случая двойката камъни да е от по-тежката страна, с останалите 2 премервания можем да разграничим най-много \( 3^2 = 9 \) случая, т.е. те са недостатъчно. <br>
- 1:3 (един камък спрямо три камъка).<br>
Едно такова премерване няма да ни даде никаква нова информация, тъй като 3 камъка са винаги по-тежки от един.<br>
- 2:2 (два камъка спрямо два камъка).<br>
Това измерване е единственото, което разделя 24-те възможни конфигурации на камъните на равен на брой подслучаи (8-8-8), т.е. получаваме \( \log _{2} 3 \) бита информация. Това означава, че с оставащите 2 измервания ще трябва да определим еднозначно в коя от оставащите 8 възможности се намираме, което изглежда теоретично възможно. Оказва се, обаче, че нямаме следващо измерване, което да ни даде \(\log _{2} 3 \) бита информация. Например един възможен изход от първото измерване е везната да е балансирана. Повторно премерване от вида (2:2) с друга конфигурация на камъните със сигурност не може да балансира везната. Това е валидно и за премерване от вида (1:1) и (1:3), а премерването (1:2) не разпределя равномерно оставащите случаи (което е необходимо условие за \(\log _{2} 3 \) бита нова информация). Случаят (1:2), когато двата камъка са избирани от различни страни на везната (спрямо първото претегляне), разделя възможните конфигурации на камъните на (2-5-1), което в най-лошия за нас случай оставя 5 възможности, т.е. получаваме под 1 бит информация. Измерване от вида (1:2), когато оставяме двата камъка от едната страна на везната (от първото претегляне), отново никога не балансира везната. Тъй като второто измерване ни дава най-много 1 бит нова информация (т.е. от 8 случая остават поне 4), то третото измерване със сигурност е недостатъчно, а от гледна точка на информацията попадаме в неравенството \( \log_2 3 + 1 +\log_2 3 \lt \log_2 24 \).<br><br>

Въпреки че на пръв поглед непровереният теоретичен минимум ни навежда към 3 претегляния, липсата на практически алгоритъм (поредица от измервания, които да дават всеки път \(\log _{2} 3 \) бита нова информация) води до необходимост от 4 претегляния за решение на задачата в общия случай.<br>
<b>Отговор: 4 претегляния</b>
<hr>
 Основите на <a href="https://bg.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BD%D0%B0_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F%D1%82%D0%B0" target=_blank>теорията на информацията</a> са положени от <a href="https://bg.wikipedia.org/wiki/%D0%9A%D0%BB%D0%BE%D0%B4_%D0%A8%D0%B0%D0%BD%D1%8A%D0%BD" target=_blank>Клод Шанън </a> (<a href="https://en.wikipedia.org/wiki/Claude_Shannon" target=_blank>Claude Shannon</a>), срещащ се в литература още под името Шенон. В негова чест е кръстена и мерната единица за информация Шенон, която отдавна е отстъпила място на далеч по-популярния бит. 1 <a href="https://en.wikipedia.org/wiki/Shannon_(unit)" target=_blank>Шенон</a> информация = 1 бит информация = информацията, която получаваме от събитие, което се случва с вероятност 50% = ентропията на система, която има 2 възможни и равновероятностни състояния.<br>
 В решението на задачата често се налагаше да работим с \(\log _{2} 3 \) бита информация, която получаваме от събитие с три възможни и равно вероятни изхода. Това количество информация е равно точно на 1 трит (<a href="https://en.wikipedia.org/wiki/Ternary_numeral_system" target=_blank>trit</a>).
	</div>
</div>
</div>
<!-- end of week 2-->
<input type="checkbox" id=week3Toggle>
<label for=week3Toggle class="week">
<h2 id=week3>Седмица №3 <span></span></h2>
</label>	
<div>
<h3 id="week3,question1">Счупеният асансьор</h3>
<p>Асансьор в 100-етажна сграда се е развалил и работят само два аварийни бутона. Единият бутон е син, с който асаньорът се изкачва 7 етажа, при условие че асансьорът се намира под 94-тия етаж. Другият бутон е жълт, с който асансьорът слиза 9 етажа, при условие че асансьорът е над 9-тия етаж.<br>
Ако асаньорът е на 1-вия етаж, с колко най-малко придвижвания (натискане на авариен бутон) можем да го закараме на 72-рия етаж.</p>
<div>
	<input type="checkbox" id=solution31><label class="explanationbutton" for=solution31><span>Обяснение</span></label>
	<div class="explanation">
Нека предположим, че трябва да натиснем общо \( x \) пъти синия и \( y \) пъти жълтия бутон. Тогава:<br>
\( 1 + 7x -9y = 72 \implies 7x=9y+71 \iff x=y+10+ \dfrac{2y+1}{7} \)<br>
Тъй като \( x \) и \( y \) са цели положителни числа (или 0), то  \( y = 3,10,17 \dots , y \equiv 3 ~( \text{mod } 7 ) \)<br>
При \( y = 3 \) получаваме \( x = 14 \) или общо 17 придвижвания.<br>
При \( y = 10 \) получаваме \( x = 23 \) или общо 33 придвижвания.<br>
Сравнително лесно се забелязва, че с всяка следваща възможна стойност за  \( y \) крайният брой придвижвания само се увеличава. <br>
Възможно решение ли е \( y = 3 \) и \( x = 14 \)?
Макар и не всеки път да са възможни и двата бутона, сигурни сме, че поне един от тях е възможен, например:<br>
\(1 + 10*7 = 71, 71 - 3*9=44, 44 + 4*7 = 72\)<br>
<b>Отговор: 17</b> <br>
Задачата е достатъчно лесна и за решение чрез програма, която генерира и проверява последователно всички възможни двойки  \( x \) и \( y \)  (отново естествени числа или 0), като стандартният алгоритъм за това е:
<ol>
<li>Генерираме последователно всяко естествено число  (\( sum \))  </li>
<li>За всяко \( sum \) генерираме всички възможни двойки \( x \) и \( y \), такива че \( x + y = sum \)</li>
<li>Проверяваме всяка получена двойка \( x \) и \( y \) дали удовлетворява уравнението \( 1 + 7x -9y = 72 \)</li>
</ol>
Тъй като ние генерираме сумата на \( x \) и \( y \)  последователно, можем да сме сигурни, че когато уравнението е изпълнено за пръв път, сме намерили най-малката възможна сума.
{:/}

```java
IntStream.iterate(0, i -> i + 1).filter(sum -> {
	return IntStream.rangeClosed(0, sum).filter(x -> {
		int y = sum - x;
		if (1 + 7*x - 9*y == 72) {
			System.out.println(sum + ": x=" + x + ", y=" + y);
			return true;
		} else {
			return false;
		}
	}).findFirst().isPresent();
}).findFirst();
```
{::nomarkdown}
<div style="background: #000;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 90%;">17: x=14, y=3
</div>
	</div>
</div>
<h3 id="week3,question2">Рекурсия</h3>
<p> \( f(n) = \begin{cases} n-3 ~~~\text{ , при } n\gt2020 \\ f^n(4n) \text{ , в противен случай }\end{cases} \)
<br>където<br>
\( f^1(n) = f(n) \) <br> \( f^2(n) = f(f(n)) \) <br> <!-- \( f^3(n) = f(f(f(n))) \) <br> --> \( \cdots \) <br> \( f^p(n) = \underbrace{f( \dots f(f(}_\text{p пъти} n)) \dots) \)<br>
<nobr>Да се намер \( f(1)=\text{ ?} \)</nobr><br>
Ако \( f(1) \) не е изчислимо, отговорете с английската буква u (от undefined).</p>
<div>
	<input type="checkbox" id=solution32><label class="explanationbutton" for=solution32><span>Обяснение</span></label>
	<div class="explanation">
Първото нещо, с което трябва да се съобразим, е, че \( f^m(f^n(x)) = f^{m+n}(x)  = f^{m+n -1}(f(x)) \) <br> <!-- = f^n(f^m(x))  -->
<br>
<h4>Решението на програмиста:</h4>
Дефиницията на функцията е достатъчно лесна, за да можем да я имплементираме дословно:
{:/}

```java
private int f(int n) {
	if (n > 2020) {
		return n - 3;
	} else {
		int currentResult = f(4*n);
		for(int i = 1; i < n; i++) {
			currentResult = f(currentResult);
		}
		return currentResult;
	}
}
```
Една малко по-оптимална имплементация би била итеративната, например:
```java
int n = 1;
int timesToApply= 1;
while(timesToApply > 0) {
	timesToApply --;
	if (n > 2020) {
		n -= 3;
	} else {
		timesToApply += n;
		n *= 4;
	}
}
System.out.println(n);
```
{::nomarkdown}
<div style="background: #000;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 90%;">2020</div>
<br>
<h4>Решението на математика:</h4>
<big> 
\( f(1) = f^1(4) = f^4(4*4) = f^4(16) \) <br>
\( f^4(16) = f^3(f(16)) = f^3(f^{16}(16*4)) = f^{3+16}(64)\) <br>
\( f^{3+16}(64) = f^{2+16+64}(256) = f^{1+16+64+256}(1024) = f^{16+64+256+1024}(4096) \)<br>
\( f^{16+64+256+1024}(4096) = f^{1360}(2020 + 3*692) = f^{1360-692}(2020) = f^{668}(2020) \)<br>
\( f^{668}(2020) = f^{667+2020}(4*2020) = f^{667+2020}(2020 + 3*2020) = f^{667}(2020) \)<br>
\( f^{667}(2020) = f^{666 + 2020}(4*2020) = f^{666 + 2020}(2020 + 3*2020) = f^{666}(2020) \)<br>
\( \cdots  \)<br>
\( f^{668}(2020) = f^{667}(2020) = \cdots = f^{1}(2020)  \)<br>
\( f^1(2020) = f^{2020}(4*2020) = f^{2019+1}(2020 + 3*2019+3) = f^1(2020+3) = 2020 \)<br>
\( \mathbf{\implies f(1) = 2020} \)<br>
</big>
<br>
За естествени числа функцията може да се дефинира по следния еквивалентен и много по-лесен за изчисление начин:
\( f(n) =  \begin{cases} 2018 ~\text{ , при } n \lt 2020  \text{ и } n \equiv 2 \pmod 3  \\ 2019 ~\text{ , при } n \lt 2020  \text{ и } n \equiv 0 \pmod 3  \\ 2020 ~\text{ , при } n \le 2020  \text{ и } n \equiv 1 \pmod 3  \\  n-3 \text{ , при } n \gt 2020  \end{cases}  \)
	</div>
</div>
<h3 id="week3,question3">Четирите четворки</h3>
<p>Разполагаме с четири четворки: <font color="darkred"><b>4 4 4 4</b></font>, с двуаргументните аритметични операции събиране (<font color="darkred"><b>+</b></font>), изваждане (<font color="darkred"><b>-</b></font>), умножение (<font color="darkred"><b>∗</b></font>) и деление (<font color="darkred"><b>/</b></font>), както и с едноаргументната аритметична операция квадратен корен (<font color="darkred"><b>√</b></font>), приложима както върху числа, така и върху подизрази. Всяка операция можем да ползваме произволен, краен брой пъти. Съседни цифри, между които не поставим операция, участват в израза като многоцифрено число.<br>
Приемаме, че важат стандартните приоритети на операциите (умножението и делението са с по-висок приоритет от събирането и изваждането), операциите са ляво асоциативни (т.е. операции с един и същи приоритет се изпълняват от ляво надясно, например <font color="darkred">4/4/4∗4</font>=1) и не можем да използваме скоби за смяна на така дефинираната последователност на изчисленията.<br>
Като ползваме тези правила, се опитваме да съставим валидни аритметични изрази, които са равни съответно на 1, 2, 3 и т.н.<br>
Примери с валидни изрази:<br>
<ol>
	<li><span style="font-size:small">\( \sqrt{44}/\sqrt{44} = 1\)</span></li>
	<li><span style="font-size:small">\( \sqrt{4/\sqrt{4/\sqrt{4*4}}} = 2 \)</span></li>
	<li style="list-style-type: none;">...</li>
</ol>
Кое е първото (най-малкото) естествено число, за което не можем да съставим валиден аритметичен израз?</p>
<div>
	<input type="checkbox" id=solution33><label class="explanationbutton" for=solution33><span>Обяснение</span></label>
	<div class="explanation">
Примерни аритметични изрази:
<ol>
	<li> \( 44/44  = 1 \)</li>
	<li> \( 4/4 + 4/4 = 2 \)</li>
	<li> \( 4/4+4/\sqrt{4} = 3 \)</li>
	<li> \( \sqrt{4*4+4-4} = 4 \)</li>
	<li> \( \sqrt{4*4}+4/4 = 5 \)</li> 
	<li> \( 4+\sqrt{4-4+4} = 6 \)</li> 
	<li> \( 44/4-4 = 7 \)</li> 
	<li> \( 4+4+4-4 = 8 \)</li>
	<li> \( 4+4+4/4 = 9 \)</li> 
	<li> \( 4+4+4/\sqrt{4} = 10\)</li> 
	<li> \( 44/\sqrt{4*4} = 11\)</li>
	<li> \( 4+4+\sqrt{4*4} = 12\)</li> 
	<li> \( 44/4+\sqrt{4} = 13\)</li> 
	<li> \( 4+4+4+\sqrt{4} = 14 \)</li> 
	<li> \( 44/4+4 = 15 \)</li> 
	<li> \( 4*4*4/4  = 16 \)</li>
	<li> \( 4*4+4/4  = 17 \)</li>
	<li> \( 4*4+4-\sqrt{4} = 18 \) </li> 
	<li style="color:darkred">Не съществува аритметичен израз, равен на 19</li>
</ol>
<b>Имплементационни детайли:</b><br>
Тъй като операцията корен квадратен е едноаргументна, тя може да се ползва произволно много пъти, т.е. не е възможно да генерираме всички възможни аритметични изрази. От друга страна обаче, ние се интересуваме само от аритметични изрази, които връщат като резултат цяло число, и това ни позволява да направим следните ограничения:
<ul>
<li>\( \sqrt{\sqrt{4}}=\sqrt{2} \) e ирационално число и един лесен начин да получим като краен резултат цяло число е да имаме деление или изваждане със същото ирационално число, т.е. получаваме подизрази от вида  \( \sqrt{\sqrt{4}}/\sqrt{\sqrt{4}} = \sqrt{\sqrt{\sqrt{4}}}/\sqrt{\sqrt{\sqrt{4}}} = \dots = 1 \), които обаче са еквивалентни и можем да пропуснем, фокусирайки се само върху изрази и подизрази с минимален брой операции за коренуване. </li>
<li>Три вложени квадратни корена върху един единствен аритметичен подизраз може да доведе до краен резултат цяло число при положение, че не ползваме деление, само в следните случаи: <ul><li>\( \sqrt{\sqrt{\sqrt{4}}}*\sqrt{\sqrt{\sqrt{4*4*4}}}=2 \)</li>  <li>\( \sqrt{\sqrt{\sqrt{4*4}}}*\sqrt{\sqrt{\sqrt{4*4}}}=2 \)</li>   <li>\( \sqrt{\sqrt{\sqrt{4*4*4}}}*\sqrt{\sqrt{\sqrt{4}}}=2 \)</li> <li style="list-style-type: none;">...</li> <li>\( \sqrt{\sqrt{\sqrt{4}}}*\sqrt{\sqrt{\sqrt{4}}}*\sqrt{\sqrt{\sqrt{4}}}*\sqrt{\sqrt{\sqrt{4}}}=2 \)</li></ul>
Тези случаи можем да изпуснем, тъй като аритметичен израз, равен на 2, можем да получим и по друг начин - нещо, което е видно и в примерите към условието.
</li>
<li> 4 и повече вложени квадратни корени върху един единствен подизраз или число не могат да участват в аритметичен израз, който да бъде равен на цяло число, без да попадаме в първия случай.</li>
</ul>
<br>
За да указваме еднозначно аргумента на операцията квадратен корен, ще ползваме записа sqrt(&lt;подизраз&gt;), например sqrt(4).<br>
Използвайки мета-езика на Бекус-Наур (<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" target=_blank>Backus–Naur form</a>), можем да дефинираме (рекурсивно) възможните аритметични изрази, от които се интересуваме, по следния начин: <br>
<style>
.definition { color: black;}
.definition::before {content: "<";}
.definition::after {content: ">";}
.separator {color:black;}
.obsolete {color:grey;}
</style>
<ul>
<li><span class="definition">op</span> ::= + <span class="separator">|</span>  - <span class="separator">|</span>  * <span class="separator">|</span>  / </li>
<li><span class="definition">expr1</span> ::= 4 <span class="separator">|</span>  sqrt(4) <span class="separator">|</span>  sqrt(sqrt(4))</li>
<li><span class="definition">expr2</span> ::= 44 <span class="separator">|</span>  sqrt(44) <span class="separator">|</span>  sqrt(sqrt(44)) <span class="separator">|</span>  <span class="definition">expr1</span> <span class="definition">op</span> <span class="definition">expr1</span> <span class="separator">|</span>  sqrt(<span class="definition">expr1</span> <span class="definition">op</span> <span class="definition">expr1</span>) </li>
<li><span class="definition">expr3</span> ::= 444 <span class="separator">|</span>  <span class="obsolete">sqrt(444)</span> <span class="separator">|</span>  <span class="definition">expr1</span> <span class="definition">op</span> <span class="definition">expr2</span> <span class="separator">|</span>  sqrt(<span class="definition">expr1</span> <span class="definition">op</span> <span class="definition">expr2</span>) <span class="separator">|</span>  <span class="definition">expr2</span> <span class="definition">op</span> <span class="definition">expr1</span> <span class="separator">|</span>  sqrt(<span class="definition">expr2</span> <span class="definition">op</span> <span class="definition">expr1</span>)</li>
<li><span class="definition">expr4</span> ::= 4444 <span class="separator">|</span> <span class="obsolete">sqrt(4444)</span> <span class="separator">|</span>  <span class="definition">expr2</span> <span class="definition">op</span> <span class="definition">expr2</span> <span class="separator">|</span>  sqrt(<span class="definition">expr2</span> <span class="definition">op</span> <span class="definition">expr2</span>) <span class="separator">|</span>  <span class="definition">expr3</span> <span class="definition">op</span> <span class="definition">expr1</span> <span class="separator">|</span>  sqrt(<span class="definition">expr3</span> <span class="definition">op</span> <span class="definition">expr1</span>) <span class="separator">|</span>  <span class="definition">expr1</span> <span class="definition">op</span> <span class="definition">expr3</span> <span class="separator">|</span>  sqrt(<span class="definition">expr1</span> <span class="definition">op</span> <span class="definition">expr3</span>)</li>
</ul>
Някои излишни случаи, които не водят до изрази, равняващи се на цяло число, са добавени за пълнота в сиво.<br>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2020/week3/TheFour4s.java" target="_blank">Примерен Java код</a>
<hr>
Задачата с четирите четворки е била поставена за пръв път в края на 19<sup>-ти</sup> век, като бързо става  популярна сред любителите на математиката. Разбира се, съществували са различни интерпретации за това кои операции са основни и позволени. През 30<sup>-те</sup> години на миналия век задачата отново набира популярност. Тогава известният физик Пол Дирак (<a href="https://en.wikipedia.org/wiki/Paul_Dirac" target=_blank>Paul Dirac</a>), който освен физик е бил и голям любител на математическите пъзели, успява да даде елегантно решение за произволно естествено число, като използва в допълнение двуаргументната операция логаритъм. (\( a=b^c \iff \log_{b}a = c \), \( \log_{b}(b^a) = a \))
<ul style="align:left; width: 1px; overflow: visible;">
	<li>$$ \log_{\sqrt{4}/4}(\log_4\sqrt{4}) = \log_{1/2}(\log_4 4^{1/2}) = \log_{1/2}1/2=1$$</li>
	<li>$$ \log_{\sqrt{4}/4}(\log_4\sqrt{\sqrt{4}}) = \log_{1/2}(\log_4 4^{\frac{1}{2}*\frac{1}{2}}) = \log_{1/2}(\log_4 4^{(1/2)^2}) = \log_{1/2}(1/2)^2=2$$</li>
	<li>$$ \log_{\sqrt{4}/4}(\log_4\sqrt{\sqrt{\sqrt{4}}}) = \log_{1/2}(\log_4 4^{(1/2)^3}) = \log_{1/2}(1/2)^3=3$$</li>
	<li style="list-style-type: none;">...</li>
	<li>$$ \log_{\sqrt{4}/4}(\log_4\underbrace{\sqrt{\dots \sqrt{4}}}_\text{n пъти}) = \log_{1/2}(\log_4 4^{(1/2)^n}) = \log_{1/2}(1/2)^n=n$$</li>
</ul>
	</div>
</div>
</div>
<!-- end of week 3-->
<input type="checkbox" id=week4Toggle>
<label for=week4Toggle class="week">
<h2 id=week4>Седмица №4 <span></span></h2>
</label>	
<div>
<h3 id="week4,question1">Числото на Петко</h3>
<p>Петко си намислил едно голямо число, за което твърдял, че:
<ol>
	<li>Числото се дели на 1</li>
	<li>Числото се дели на 2</li>
	<li>Числото се дели на 3</li>
	<li style="list-style-type: none;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... </li>
	<li value="30">Числото се дели на 30</li>
	<li value="31">Числото се дели на 31</li>
</ol>
В последствие се оказало, че две последователни твърдения са неверни, а всички останали са верни.<br>
Кои са неверните твърдения?</p>
<div>
	<input type="checkbox" id=solution41><label class="explanationbutton" for=solution41><span>Обяснение</span></label>
	<div class="explanation">
Нека обозначим числото на Петко с \(P\).<br>
Тъй като всяко число се дели на 1, първото твърдение винаги е вярно.<br>
Ако допуснем, че \(P\) не се дели на 2, то тогава всяко четно твърдение няма да е вярно (\(P\) няма да се дели и на 4 и на 6 и т.н.) Но ние знаем, че само две, при това последователни, твърдения са неверни. Следователно допускането ни е грешно и \(P\) трябва да се дели на 2.<br>
С аналогични разсъждения можем да стигнем до извода, че числото на Петко се дели и на 3, 4, 5 и т.н. до 15 включително.<br>
16 е първото число, при което не стигаме до противоречие при допускането, защото няма друго число в интервала [1, 31], което се дели на 16.<br>
От това, че \(P\) се дели на всички числа от 1 до 15, следва обаче, че числото се дели и на всяко следващо четно число от интервала [18,30]. Това са числа, които ако бъдат разложени на прости множители, ще съдържат 2 най-малко един път (понеже са четни) и най-много три пъти, т.е. могат да бъдат представени като \((2^n)*k\) при n ∈ [1,3], k ∈ [9, 15]. Това са две взаимно прости числа, за които вече знаем, че делят \(P\) без остатък.<br>
Следователно единствените последователни числа, които могат да не делят числото на Петко, са <b>16 и 17</b>.<br>
Най-малкото такова число \(P_0\) е равно на \(2^3*3^3*5^2*7*11*13*19*23*29\), а всяко друго число, отговарящо на условието, ще бъде кратно на  \(P_0\).
	</div>
</div>
<h3 id="week4,question2">Голямата полемика</h3>
<p>Група от 45 ученици обсъждали разпалено решението на една задача. Първоначално 13 от учениците вярвали в правотата на решение и отговор 1, други 15 от учениците - в отговор 2, и останалите 17 - в отговор 3. Задачата била толкова трудна и противоречива, че всеки път, когато двама ученика с различни отговори се срещали да обсъдят решението, те взаимно се убеждавали, че грешат. В резултат на това и двамата започвали да вярват в решението и отговора, в което първоначално никой от тях не вярвал.<br>
Кои от следните твърдения са верни?<br>
Приемаме, че всеки ученик може да промени отговора си произволен брой пъти, дискусиите в групата се провеждат винаги по двама и външни хора не участват.
<ul class="answersWithCheckbox">
	<li>Възможно е след определено време във всеки отговор да вярват един и същи брой ученици.</li>
	<li>Няма как след определено време във всеки отговор да вярват един и същи брой ученици.</li>
	<li>Няма как след определено време един и същи брой ученици да вярват в отговор 1 и отговор 3.</li>
	<li>Възможно е след определено време всеки ученик да вярва, че отговор 1 е верен.</li>
	<li>Възможно е след определено време всеки ученик да вярва, че отговор 2 е верен.</li>
	<li>Възможно е след определено време всеки ученик да вярва, че отговор 3 е верен.</li>
	<li>Няма как след определено време всички ученици да вярват в един и същи отговор, независимо кой е той.</li>
</ul>
</p>
<div>
	<input type="checkbox" id=solution42><label class="explanationbutton" for=solution42><span>Обяснение</span></label>
	<div class="explanation">
<h4>Решението на програмиста:</h4>
Тъй като възможностите за групиране на учениците не са много, можем да проверим всяка една от тях. <br>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2020/week4/TheBigDispute.java" target="_blank">Примерен Java код</a><br>
<h4>Решението на математика:</h4>
В една толкова динамична среда, в която всичко се променя, трябва да потърсим свойство на системата или стойност, които остават постоянни във времето. В математиката една такава непроменяща се стойност се нарича инварианта (<a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" target=_blank>Invariant</a>).<br>

Имаме три групи ученици, вярващи в три различни отговора. Ще разгледаме остатъка на броя ученици във всяка от тях при деление на 3. <br>
13 ≡ 1 (mod 3)<br>
15 ≡ 0 (mod 3)<br>
17 ≡ 2 (mod 3)<br>
Ако се срещнат ученик от 1-ва и ученик от 2-ра група, ще получим съответно 12, 14 и 19 ученици, или:<br>
12 ≡ 0 (mod 3)<br>
14 ≡ 2 (mod 3)<br>
19 ≡ 1 (mod 3)<br>
Ако се срещнат ученик от 1-ва и ученик от 3-та група, ще получим съответно 12, 17 и 16 ученици, или:<br>
12 ≡ 0 (mod 3)<br>
17 ≡ 2 (mod 3)<br>
16 ≡ 1 (mod 3)<br>
И последният възможен случай е да се срещнат ученик от 2-ра и ученик от 3-та група, като получаваме съответно 15, 14 и 16 ученици, или:<br>
15 ≡ 0 (mod 3)<br>
14 ≡ 2 (mod 3)<br>
16 ≡ 1 (mod 3)<br>
Тъй като започнахме от разпределение на остатъците, съответно 1, 0 и 2, и след всички възможни промени в следствие на една среща на двама ученика, получаваме отново разпределение, при което имаме по точно една група със съответно остатъци 0, 1 и 2, то това свойство остава постоянно във времето и играе ролята на инварианта. Важно е да уточним, че не знаем при коя конкретно група броят ученици ще дава остатък 0 при деление на 3, но знаем, че винаги ще има една и само една такава група.<br>
- Ако допуснем, че в даден момент еднакъв брой ученици вярват в отговор 1 и отговор 3, то тогава броят ученици в тези две групи ще дава еднакъв остатък при деление на 3, което е невъзможно.<br>
- Ако допуснем, че всички ученици вярват в правотата на един отговор, то в другите два отговора ще вярват по 0 ученици, т.е. ще получим разпределение на остатъците при делене на 3 съответно 0, 0 и 0. Kакто вече знаем, това е невъзможно.<br>
- Аналогично, ако в даден момент в правотата на всеки отговор вярват по 15 ученици, то отново разпределението на остатъците би било 0, 0 и 0. <br>
Следователно верните твърдения са:
<ul> 
<li><b>Няма как след определено време във всеки отговор да вярват един и същи брой ученици.</b></li>
<li><b>Няма как след определено време един и същи брой ученици да вярват в отговор 1 и отговор 3.</b></li>
<li><b>Няма как след определено време всички ученици да вярват в един и същи отговор, независимо кой е той.</b></li>
</ul>
Всички останали твърдения са грешни.<br>
Алтернативни, в някаква степен производни, инварианти за конкретната задача: 
<ul>
<li>Разликата на броя ученици, които вярват в отговор 1 и отговор 3, е винаги число, което не се дели на 3;</li>
<li>Винаги има една и само една група ученици, чийто брой се дели на 3.</li>
</ul>
<hr>
Обикновено свързваме математиката с абсолютна точност и непоклатима логика. Това не означава обаче, че това е винаги лесно постижимо. В исторически план има много случаи, в които математици откриват противоречия, водещи в последствие до промени и подобрения във вече наложили се теории, дори и в основни клонове на математиката. Известен пример за това е <a href="https://bg.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%BD%D0%B0_%D0%A0%D1%8A%D1%81%D0%B5%D0%BB#%D0%9E%D0%B1%D1%8F%D1%81%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0_%D0%BD%D0%B5%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%86%D0%B8" target=_blank>Парадоксът на Ръсел</a> (<a href="https://en.wikipedia.org/wiki/Russell%27s_paradox" target=_blank>Russell's Paradox</a>) от теорията на множествата,  подробно обяснен и в <a href="https://plato.stanford.edu/entries/russell-paradox/" target=_blank>Stanford Encyclopedia of Philosophy</a>). Парадоксът съществува в по-достъпна и популярна форма под името <a href="https://iskamdaznam.com/paradoksi/6/" target=_blank>Парадоксът на бръснаря</a> (<a href="https://en.wikipedia.org/wiki/Barber_paradox" target=_blank>Barber paradox</a>), който гласи следното:<br>
<blockquote><p>Бръснарят на града е човекът, който бръсне тези и само тези, които не се бръснат сами.</p></blockquote>
Въпросът е кой бръсне бръснаря? Твърдението:
<blockquote><p>Бръснарят се бръсне сам.</p></blockquote>
не е вярно, защото бръснарят бръсне само тези, които не се бръснат сами! А отрицанието на същото твърдение:
<blockquote><p>Бръснарят не се бръсне сам.</p></blockquote> 
също не е вярно, понеже при това положение той самият е сред тези, които трябва да бръсне.<br>
Съществуването на твърдение (за принадлежност към множество), което не е вярно, в комбинация с това, че и отрицанието на твърдението не е вярно, създава истински логически парадокс в така наречената "наивна" теория на множествата. По-задълбоченият (съвременен) анализ показва, че парадокс в смисъла на логическо противоречие не съществува. Повече за парадокса и начините за неговото разрешаване можете да прочетете в статията <a href="https://brilliant.org/wiki/russells-paradox/" target=_blank>Russell's Paradox</a> в сайта Brilliant.
	</div>
</div>
<h3 id="week4,question3">Oгърлици</h3>
<p>Колко различни огърлици могат да бъдат направени от 4 жълти, 6 сини и 8 червени мъниста, като ползваме винаги всички налични мъниста?<br>
Две огърлици са различни, когато не можем да получим цветовата наредба на мънистата на едната огърлица чрез завъртане и/или преобръщане на другата огърлицата.<br>
Топчетата мъниста от един цвят са еднакви и неразличими помежду си, т.е. разменяйки местата на две мънистa с еднакъв цвят, няма да променим огърлицата.<br>
Пример: Трите огърлици от снимката са еднакви и трябва да бъдат преброени като една уникална огърлица, а номерирането на мънистата е условно.<br>
Средната огърица получаваме след завъртане на лявата на 180°, а дясната получаваме от средната като я обърнем надясно.
<img style="display:block; max-width: 80%; height: auto; vertical-align: middle; border: 0;" src="/technoteaser/docs/images/2020/u1IlL-QV0lNpsWPI9dfs7flyBfMJk4mYMYWHHhN8Ptc.jfif">
</p>
<div>
	<input type="checkbox" id=solution43><label class="explanationbutton" for=solution43><span>Обяснение</span></label>
	<div class="explanation">
<h4 id="week4,solution43,ProgramSolution">Решението на програмиста:</h4>
Както повечето комбинаторни задачи със сравнително малък общ брой случаи, и тук най-лесният начин за преброяване е като генерираме всички възможни наредби и преброим различните от тях (<a href="https://en.wikipedia.org/wiki/Brute-force_search" target=_blank>Brute-force</a> търсене). Първата стъпка е да помислим за удобно представяне на огърлицата. <br>Тъй като работата с циклична структура от данни е по-трудна, можем да приемем, че огърлицата условно има начало и край. По този начин можем да представим огърлицата като 18-цифрено число, в което всяко жълто мънисто е представено чрез цифрата 1, всяко синьо мънисто - с цифрата 2, и всяко червено мънисто - с цифрата 3. Тъй като <code><pre style="display: inline; color:black; line-height: normal; margin:0; padding: 0; border:1px; ">Long.MAX_VALUE</pre></code> (2<sup>63</sup>-1) е число с 19 цифри, то тип long би бил напълно достатъчен. Трябва, разбира се, да съобразим, че много различни числа ще представляват една и съща огърлица. Това е така от една страна заради условното начало и край, т.е. ако последната цифра на числото направим първа, ще получим друго число, представящо същата огърлица. От друга страна, имаме възможност да преобърнем огърлицата, т.е. ако изпишем числото в обратен ред, отново ще получим друго представяне на същата огърлица.<br>
Алгоритъмът за преброяване на различните огърлици се свежда до няколко основни стъпки:<br>
<ol>
<li>Генерираме всички възможни 18-цифрени числа, съдържащи 4 пъти цифрата 1, 6 пъти цифрата 2 и 8 пъти цифрата 3;</li>
<li>В подходяща структура от данни, например <code><pre style="display: inline; color:black; line-height: normal; margin:0; padding: 0; border:1px; ">HashSet&lt;Long&gt;</pre></code>, пазим генерираните към момента числа. Ако текущото число не е налично в тази структура, преброяваме още една уникална огърлица, след което добавяме към структурата текущото число, както и всички други числа, представящи същата огърлица. Това са числата, които можем да получим от текущото число, като преместваме последната цифра като първа (ротация), и числата, получени чрез изписване на цифрите на текущото число в обратен ред (преобръщане) и приложим отново възможните ротации.</li>
</ol>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2020/week4/Necklace.java" target="_blank">Примерен Java код</a><br><br>
Отговор: <b>255920</b>
<h4 id="week4,solution43,MathSolution">Решението на математика:</h4>
Нека означим цветовете с <font color="darkred">a</font>, <font color="darkred">b</font> и <font color="darkred">с</font>, и те се срещат съответно 4, 6 и 8 пъти. Разглеждаме пермутациите на стринга <font color="darkred">aaaabbbbbbcccccccc</font>. Те са \(\dfrac{18!}{4!*6!*8!} = 9189180 \). Всяка пермутация съотвества на огърлица. Една пермутация можем да транслираме циклично или да обърнем огледално, като по този начин получилата се пермутация съответства на същата огърлица.<br>
<b>Цикъл</b> на дадена пермутация ще наричаме броя на различните пермутации, които можем да получим като започнем от дадена пермутация и прилагаме горните две пермутации. Всички пермутации от един цикъл съответстват на една и съща огърлица и при това няма пермутации извън цикъла, които съответстват на същата огърлица. Повечето пермутации имат цикъл 	\(18*2=36\), защото можем да транслираме пермутацията 18 пъти и всяка транслация може да се обърне. Обаче има и пермутации с по-малък цикъл.<br>
<b>Транслационен цикъл</b> на една пермутация ще наричаме броя на различните пермутации, които се получават само с транслация. Например, abcabc има транслационен цикъл от 3. Транслационният цикъл за дадените пермутации е делител на 18. Лесно се убеждаваме, че не може да е 6, 3 или 1, защото това ще означава, че една пермутация може да се раздели на 3, 6 или 18 еднакви стринга, което е невъзможно, т.е. транслационният цикъл може да е само 18 и 9. Ако е 9, пермутацията се разделя на два равни стринга. <br> Можем да заключим, че:<br>
- Цикълът на една пермутация е ≥ транслационния ѝ цикъл.<br>
- Цикълът на една пермутация може да е само 9, 18 или 36.<br>
<ol><li><b>Цикъл 9</b> имат само пермутации от вида <font color="darkred"><u>ccabbbacc</u>ccabbbacc</font>, които са съставени от два еднакви палиндрома. По средата на палиндрома задължително има b заради нечетния брой срещания на тази буква. От лявата страна на палиндрома можем да подредим елементите по \(\dfrac{4!}{1!*1!*2!} = 12\) начина. Подреждането на лявата страна на палиндрома определя целия стринг. Така получихмe <b>12 цикъла с по 9 пермутации</b>.</li>
<li><b>Цикъл с дължина 18</b> имат пермутации със следната структура:
<ul>
	<li>Палиндроми, които не сме преброили вече в подточка 1, и техните производни чрез транслация и обръщане. Например <font color="darkred">ccccbbbaaaabbbccccc</font>.<br>
	От лявата страна на палиндрома можем да подредим буквите по \(\dfrac{9!}{2!*3!*4!}\) начина, като по този начин ще получим 1260 палиндрома. 12 от тях ще са преброени по-горе, остават 1248. Заради симетрия ще сме ги преброили два пъти - тоест <b>имаме 624 уникални цикъла, които съдържат 624*18 стринга</b>.</li>
	<li><font color="darkred">&lt;стринг w&gt;X&lt;w обърнато&gt;X</font>, където X е една от буквите a,b,c. Например <font color="darkred">ccccbbaabaabbcccccb</font>.<br>
	Разглеждаме вариантите за X:
	<ol style="list-style-type: lower-alpha">
		<li style="padding-bottom: 8px">При x=a попълваме <font color="darkred">w</font> по \(\dfrac{8!}{1!*3!*4!}\) = 280 начина.</li>
		<li style="padding-bottom: 8px">При x=b попълваме <font color="darkred">w</font> по \(\dfrac{8!}{2!*2!*4!}\) = 420 начина.</li>
		<li>При x=c попълваме <font color="darkred">w</font> по \(\dfrac{8!}{2!*3!*3!}\) = 560 начина.</li>
	</ol>
	Това са общо 1260 начина. Част от стринговете от вида <font color="darkred">&lt;палиндром w&gt;X&lt;същия палиндром w&gt;X</font> вече са преброени в подточка 1 .Такива са точно 12, като остават \(1260 - 12 = 1248\), които заради симетрия отговарят на <b>624 уникални цикъла всеки с по 18 пермутации</b>.</li>
</ul></li>
<li><b>Стрингове, съставени от две равни части</b>, например <font color="darkred">aabbbccccaabbbcccc</font>, които не са броени. Лявата част можем да попълним по \(\dfrac{9!}{2!*3!*4!} = 1260\) начина. \(12*9\) от тях вече сме преброили в т.1. Остават \(1260-12*9 = 1152\) пермутации, които отговарят на <b>64 цикълa с 18 пермутации</b>.</li>
</ol>
От всички пермутации вадим намерените в подточки 1, 2 и 3 и получаваме пермутациите, които са част от цикъл с дължина 36. Те са \(9189180 - 12*9 - 624*18 - 624*18 - 64*18 = 9165456\). Това са \(9165456 / 36 = 254 596\) огърлици.<br>
Така общия брой на огърлиците е \(12 + 624 + 624 + 64 + 254 596 = \mathbf{255920} \). 
<hr>
Специални благодарности за предоставеното математическо решение на <a href="https://www.facebook.com/marin.shalamanov" target=_blank>Марин Шаламанов</a>!
	</div>
</div>
</div>
<!-- end of week 4-->
<input type="checkbox" id=week5Toggle>
<label for=week5Toggle class="week">
<h2 id=week5>Седмица №5<span></span></h2>
</label>	
<div>
<h3 id="week5,question1">Въртележка</h3>
<p>Детска въртележка има 36 седалки, разположени по окръжност, на еднакво разстояние една от друга. На всяка от седалките може да седи най-много по едно дете. Въртележката може да работи безопасно само когато децата, които се возят на нея, седят по такъв начин, че тя е балансирана, т.е. ако приемем, че всички деца са с еднакво тегло, то центърът им на тежестта трябва да съвпада с центъра на въртележката (центъра на окръжността, която седалките описват).<br>
При какъв брой деца, возещи се едновременно, съществува подредба, така че въртележката да може да работи безопасно? Маркирайте всички верни отговори!<br>
Примери: Едно дете, където и да седи, не може да се вози безопасно. Две деца, ако седят на срещуположни седалки, ще могат да се возят безопасно.<br>
<img style="display:block; max-width: 80%; height: auto; vertical-align: middle; border: 0;" src="/technoteaser/docs/images/2020/8rMMrusiucnaMYhUtlC-VggfXZx1ISei0bKUHZ8oNkA.jfif">
</p>
<div>
	<input type="checkbox" id=solution51><label class="explanationbutton" for=solution51><span>Обяснение</span></label>
	<div class="explanation">
Има няколко начина за постигане на балансирана подредба.<br>
Mоже би най-интуитивният от тях е да подредим децата така, че да се образува <b>правилна геометрична фигура</b> (правилен многоъгълник) , което означава, че между всеки две съседни деца на въртележката ще има един и същи брой свободни седалки. В примера от условието имаме две деца, които стоят на срещуположни седалки, между които  (и от двете страни на окръжността) има по 17 празни седалки.<br>
<b>1. Сегментиране</b><br>
Друг поглед върху задачата е да третираме въртележката като "торта", която трябва да разрежем на еднакви парчета (сегменти). Така във всеки сегмент ще можем да поставим по едно дете (разбира се на едно и също място). 36 се дели без остатък на 2, 3, 4, 6, 9, 12, 18 и 36, и това са възможностите ни за "разрязване" на въртележката на еднакви сегменти. Като поставим по едно дете във всеки сегмент, получаваме балансирана подредба за съответно 2, 3, 4, 6, 9, 12, 18 и 36 деца. Ако третираме въртележката като един единствен сегмент, балансирана подредба не съществува (освен за 0 деца), т.е. въпреки че 36 се дели на 1, този случай трябва да бъде изключен.<br>
<img src="/technoteaser/docs/images/2020/T1IMESpPmrBvu5dzsfW5JjHEm3PUckI0dMYQNTuDQ8E.png" width=300px style="margin-left:35px; background-color: transparent;"><br>
1.1 Можем ли да разширим възможностите за броя деца в балансирана подредба, като във всеки сегмент поставим по две (или повече) деца?<br>
Всъщност можем и това не нарушава идеята за "правилна фигура", макар и връзката да не е толкова директна. Тъй като всеки сегмент е еднакъв (като брой седалки и подредба на деца), то и центърът на тежестта на всеки сегмент ще е на еднакво разстояние от центъра на въртележката, т.е. центровете на тежестта на сегментите отново ще образуват правилна фигура. Какво можем да постигнем по този начин:
<ul>
<!--
<li> 12 сегмента, всеки с по 3 седалки и с по две деца ни дадат безопасна подредба за 24 деца;</li>
<li>9 сегмента (всеки с по 4 седалки) и с по 3 деца,  ще ни дадат безопасна подредба за 27 деца;</li>
-->
<li>2 сегмента, всеки с по 18 седалки и с по 17 деца, ще ни дадат <b>безопасна подредба за 34 деца;</b>
<br><img src="/technoteaser/docs/images/2020/sLMhi0US7E4obhNJ-rkAO5nbTih5KYlhVMboW0NWCH0.png" width=300px style="background-color: transparent;">
</li>
<li>3 сегмента, всеки с по 12 седалки и с по 11 деца, ще ни дадат <b>безопасна подредба за 33 деца;</b>
<br>
<img src="/technoteaser/docs/images/2020/zywCqrmiR07HuF6uoeIzA5VzQABBa5yPzN1CkcB9Dvs.png" width=300px style="background-color: transparent;">
</li>
<li>4 сегмента, всеки с по 9 седалки и с по 8 деца, ще ни дадат <b>безопасна подредба за 32 деца;</b><br><img src="/technoteaser/docs/images/2020/eFe9-PAstwoZYLBtD3HkujEiumJMe975qBpz-Nn2Bdo.png" width=300px style="background-color: transparent;"><br></li>
</ul>

За съжаление, само с този подход, дори и след пълна проверка на всички възможности, няма да можем да достигнем до всички решения на задачата. <br>

<b>2. Огледални решения</b><br>Решенията по-горе подсказват за друг подход - вместо да балансираме децата (тежестта), да балансираме празните седалки (липсата на тежест). Т.е. ако за безопасните подредби, които вече сме намерили, заменим празните седалки с деца, а децата - с празни седалки, ще получим отново безопасни (огледални) подредби.
По този начин от безопасна подредба за 2, 3, 4, 6, 9, 12, 18 и 36  деца получаваме съответно безопасна подредба за 34 (=36-2), 33, 32, 30, 27, 18 и 0 деца.<br>
Ако сме били изчерпателни в първия подход обаче, този няма да ни доведе до нови решения!<br>

<b>3. Събиране на решения</b><br>Съществува още един подход, който се оказва необходим, ако искаме да достигнем до всички решения. Ако имаме две балансирани подредби и можем да ги наставим, така че да не се налага на една седалка да седят две деца, то отново достигаме до балансирана подредба.
Една непосредствена проверка показва, че от балансирана подредба за 2 и за 3 деца можем да достигнем до балансирана подредба за 5 деца. От графиката по-долу се вижда, че тази подредба не може да се раздели на еднакви сегменти (липсва симетрия), поради което е силно неинтуитивна. <br>
От подхода за огледални решения знаем, че ако имаме балансирана подредба за 5 деца, то <b>имаме подредба и за</b> 36-5 = <b>31 деца</b><br>

<table border=0 style="margin: 10px 0 10px 0; background-color: transparent;">
<tr style="background-color: transparent; border-width: 0;"><td rowspan=2 style="border-width: 0;">
<img src="/technoteaser/docs/images/2020/lpVeHDvV8gbdA9XUc9uPT-fJBuSeruMqw6ToxpL9oJs.png" width=300px style="background-color: transparent;">
</td>
<td style="font-size: xx-large; padding:20px 10px 0px 10px; vertical-align: bottom; border-width: 0;"> + </td>
<td rowspan=2 style="border-width: 0;">
<img src="/technoteaser/docs/images/2020/cIx2T0u3KnpcXIA4x42YTw6iNCJAP8pSzsuM4mEzaWU.png" width=300px style="background-color: transparent;">
</td></tr>
<tr style="background-color: transparent; border-width: 0;"><td style="font-size: xx-large; padding:0px 10px 10px 10px; vertical-align: bottom; border-width: 0;">  &#8595; </td></tr>
<tr style="background-color: transparent; border-width: 0;"><td colspan=3 style="align:center; text-align:center; border-width: 0;"><img src="/technoteaser/docs/images/2020/yWxrzQRyfuj1wyx0Wp-2HGpbDKHR4GxxD6lHXswM1kI.png" width=300px style="background-color: transparent;"></td></tr>
<tr style="background-color: transparent; border-width: 0;">
<td style="border-width: 0;"></td>
<td style="font-size: xx-large; align:center; text-align:center; border-width: 0; ">  &#8595;  </td>
<td style="align:left; text-align:left; padding: 0 0 5px 0; font-size: large; vertical-align: bottom; border-width: 0;"> (огледално решение)</td>
</tr>
<tr style="background-color: transparent; border-width: 0;"><td colspan=3 style="padding: 5px 0 0 0; align:center; text-align:center; border-width: 0;"><img src="/technoteaser/docs/images/2020/mYUQ8FZQodLo4V4x6mXi5XaX3F_qDZCLRdkLV0KZ1mQ.png" width=300px style="background-color: transparent;"></td></tr>
</table>
Може ли да има безопасна подредба за 35 деца? <br>
От подхода за намиране на огледални решения следва, че ако има подредба за 35 деца, то ще има такава и за 1 дете, а това, както е указано и в примерите към условието, очевидно не е възможно.<br>

<hr>
Разбира се, такива "безопасни" детски въртележки няма. Задачата, обаче, е напълно реална и идва от един друг вид уред със сходна конфигурация -  лабораторната центрофуга (<a href="https://en.wikipedia.org/wiki/Centrifuge" target=_blank>Centrifuge</a>). Тъй като тези уреди при работа развиват висока скорост на въртене, балансът на епруветките в тях е задължителен. Затова центрофугите винаги вървят с подробно упътване за поддържания брой епруветки и тяхната конфигурация. Алтернативният подход на учените е да ползват допълнителни балансиращи епруветки със същото тегло като останалите.<br><br>
Общо решение с доказателство на задачата за балансираната центрофуга е било дадено през 2010 г. То гласи, че за центрофуга с \( n \) места за епруветки могат да се подредят балансирано \( k \) на брой епруветки с еднакво тегло  ( \( 1 ≤ k ≤ n \) ) тогава и само тогава, когато числата \( k \) и \( n-k \)  могат да се представят като сума от прости делители на \( n \). Предположението за това решение (без доказателство) е било формулирано около 15 години по-рано от биолога, изследовател на рака, Iswar Hariharan. Повече за тази история и за това как предположението намира своето доказателство можете да прочетете в блога за математика на Matt Baker - <a href="https://mattbaker.blog/2018/06/25/the-balanced-centrifuge-problem/" target=_blank> The Balanced Centrifuge Problem</a>.
	</div> 
</div>
<h3 id="week5,question2">Числова редица</h3>
<p><!-- \(x + \dfrac{1}{x} = 5\).<br> -->
Числовата редица \( \{a_i\} \) е дефинирана чрез следното правило:<br>
\( \begin{cases} a_1 = x + \dfrac{1}{x} = 5 \\ a_2 = x^2 + \dfrac{1}{x^2} \\ \cdots \\ a_i=x^i + \dfrac{1}{x^i} \end{cases} \)<br>
Коя е последната цифра на числото \( a_{2020} \)?
</p>
<div>
	<input type="checkbox" id=solution52><label class="explanationbutton" for=solution52><span>Обяснение</span></label>
	<div class="explanation">
Първата стъпка от решението на тази задача е извеждането на правило или формула, по която да изчисляваме членовете на <a href="https://bg.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B4%D0%B8%D1%86%D0%B0" target=_blank>числовата редица</a>.<br>
\(x + \dfrac{1}{x} = a_1 = 5\) (уравнение 1) <br>
Ако повдигнем двете страни на уравнение 1 на квадрат, ще получим: <br>
\( (x + \dfrac{1}{x})^2 = a_1^2 \implies \) \( x^2 + \dfrac{1}{x^2} + 2 = a_1^2 \implies \) \( x^2 + \dfrac{1}{x^2} = a_2 = a_1^2-2 = 23\) <br>
За да изведем обща формула, ще приемем, че знаем стойностите на всички членове на редицата до \( a_{n} \), и ще се опитаме да изчислим \( a_{n+1} \).<br> 
\(x^n + \dfrac{1}{x^n} = a_n\) (уравнение 2). <br>
Умножаваме (1) и (2):<br> 
\( (x^n + \dfrac{1}{x^n})(x + \dfrac{1}{x}) = a_1a_n \implies \) \( x^{n+1} + \dfrac{1}{x^{n+1}} + x^{n-1} + \dfrac{1}{x^{n-1}} = a_1a_n \implies \) \( a_{n+1} + a_{n-1} = a_1a_n \implies \) \(\mathbf{ a_{n+1} = a_1a_n - a_{n-1}} \)<br><br>

<h4 id="week5,solution52,ProgramSolution">Решението на програмиста:</h4>
Съвсем директно решение на задачата означава просто да изчислим \( a_{2020} \) като ползваме изведеното уравнение и <code><pre style="display: inline; color:black; line-height: normal; margin:0; padding: 0; border:1px; "><a href="https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html" target=_blank>java.math.BigInteger</a></pre></code> за работа с големи числа:<br>
<pre><code>BigInteger A1 = new BigInteger("5");
BigInteger previousNumber = A1;
BigInteger currentNumber = A1.pow(2).subtract(new BigInteger("2"));

for (int i=3; i<=index; i++) {
	BigInteger nextNumber =  A1.multiply(currentNumber).subtract(previousNumber);
	previousNumber = currentNumber;
	currentNumber = nextNumber;
}
System.out.println(currentNumber);</code></pre>
<div style="background: #000;border: 1px solid #ccc; color: white; display: block; padding: 5px; width: 100%;font-size: 70%; overflow-x: scroll; white-space: nowrap;">3262653790706275586117137195631050282210806285202249624059674215170806622541322511238016638929807445348664525244437169046730829301755867596276812688004115140431724947503137024220857651489729644049219168476900360817871305416288639047332959992240734609418932861127470728633492653753975304863624317403918296631387691704442221402459192013682255264173686358689234947026737052794346275861578855878661598455282976855387191207551764990635600422815955835988814503870860924025082850290043804852965017545639699649360984496060937364961456413553639872132487187890894861673433517575969576795253912023820692679443626209904572765217381815941133504243740549802444031953894392089679818193497545414357085662097178881382884068219055754377461308309468042575236052782137979415391923706117465269622546318205887064294810449330987116925746177043654374299007291673820620369507748230104072454557433310709487197774793846235611937612856242636161256723067820169241647039559273583822432738810835261652826628284416304683843344510539081489119878104600756585608063016796621318275620654342486688256023995607149516667903505011031266509450398768081266255007344491279995421146418981057216776264361827129262235373075889526998763886534440042374435597950431164189760236222310257413375826034750193403684394133633137810037743615006677165773244061158083552993934391971169243363860789123455212307332154924584446568138127</div><br>
Разбира се, точното изчисляване на \( a_{2020} \) не е нужно, а вместо това можем да се фокусирме само върху последните цифри на членовете на редицата, като съобразим, че последната цифра на  \( a_{n+1} \) зависи само от последните цифри на \( a_{n} \), \( a_{n-1} \) и \( a_1 \): <br>
<pre><code>int previousNumberLastDigit = 5;
currentNumberLastDigit = (previousNumberLastDigit*previousNumberLastDigit - 2 + 10)%10;

for (int i=3; i<=index; i++) {
	int nextNumberLastDigit = (5*currentNumberLastDigit - previousNumberLastDigit + 10)%10;
	previousNumberLastDigit = currentNumberLastDigit;
	currentNumberLastDigit = nextNumberLastDigit;
}
System.out.println(currentNumberLastDigit);</code></pre>
<div style="background: #000;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 90%; ">7</div><br>

<h4 id="week5,solution52,MathSolution">Решението на математика:</h4>
Kакто вече видяхме по-горе, последната цифра на \( a_{n+1} \)  зависи само от последните цифри на константата \( a_1 \) и предходните два елемента - \( a_{n} \) и \( a_{n-1} \).  Но последните цифри на последните два елемента (разглеждани като подредена двойка цифри) могат да формират най-много 100 различни конфигурации и следователно можем да сме сигурни, че в даден момент ще се повторят. Повторение, настъпило за последните цифри на последните два елемента, ще предизвика и повторение за последните цифри на всички следващи елементи. В конкретния случай повторението е с интервал 12:
<ol>
	<li>\( a_{1} = {\color{ darkred } 5 } \)</li>
	<li>\( a_{2} = 5*5-2 = 2{\color{ darkred } 3 } \)</li>
	<li>\( a_{3} = 5*23-5 = 110\)</li>
	<li>\( a_{4} = 5*110-23 = 527\)</li>
	<li>\( a_{5} = 5*527-110 = 2525\)</li>
	<li>\( a_{6} = 5*2525-527 = 12098\)</li>
	<li>\( a_{7} = 5*12098-2525 = 57965\)</li>
	<li>\( a_{8} = 5*57965-12098 = 277727\)</li>
	<li>\( a_{9} = 5*277727-57965 = 1330670\)</li>
	<li>\( a_{10} = 5*1330670-277727 = 6375623\)</li>
	<li>\( a_{11} = 5*6375623-1330670 = 30547445\)</li>
	<li>\( a_{12} = 5*30547445-6375623 = 146361602\)</li>
	<li>\( a_{13} = 5*146361602-30547445 = 70126056{\color{ darkred } 5 }\)</li>
	<li>\( a_{14} = 5*701260565-146361602 = 335994122{\color{ darkred } 3 }\)</li>
	<li style="list-style-type: none;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... </li>
</ol>
Тъй като 2020 ≡ 4 (mod 12), то последната цифра на \( a_{2020} \) ще бъде равна на последната цифра на \( a_4 \), т.е. <b>7</b>.
	</div> 
</div>
<h3 id="week5,question3">Малката Мери</h3>
<p>Малката Мери получила като подарък за празниците банкнота от 100 лв. Tя решила да похарчи част от тези пари (без да взема други пари със себе си), като направила серия от покупки. Оказало се, че:
<ul>
	<li>При всеки търговец Мери направила само по една покупка и съответно по едно разплащане.</li> <li>Всяка покупка била на стойност цяло число левове.</li>
	<li>Мери никога нямала точна сума пари за своите покупки.</li>
	<li>Затова Мери всеки път давала възможно най-близката до цената на всяка своя покупка сума пари, според наличните си към момента банкноти (и монети от по 1 и 2 лв.).</li>
	<li>За сметка на това търговците винаги разполагали с всички видове и достатъчно на брой банкноти и монети, затова връщали рестото с минималния възможен брой банкноти (и монети от по 1 и 2 лв.).</li>
	<li>Въпреки това рестото всеки път се състояло от поне две банкноти (и/или монети от по 1 и 2 лв.).</li>
</ul>
Колко най-много на брой покупки е направила Мери?
</p>
<div>
	<input type="checkbox" id=solution53><label class="explanationbutton" for=solution53><span>Обяснение</span></label>
	<div class="explanation">
Малката Мери е могла да направи най-много <b>8</b> покупки, като това тя е можела да направи по 513 различни начина.<br>
Например:<br>
<ol>
<li>Покупка за  20 лв.<br> Дава [100], получава ресто [10, 20, 50] и остава с банкноти [10, 20, 50] на обща стойност от 80 лв.</li>
<li>Покупка за  4 лв.<br> Дава [10], получава ресто [1, 5] и остава с банкноти [1, 5, 20, 50] на обща стойност от 76 лв.</li>
<li>Покупка за  2 лв.<br> Дава [5], получава ресто [1, 2] и остава с банкноти [1, 1, 2, 20, 50] на обща стойност от 74 лв.</li>
<li>Покупка за  9 лв.<br> Дава [20], получава ресто [1, 10] и остава с банкноти [1, 1, 1, 2, 10, 50] на обща стойност от 65 лв.</li>
<li>Покупка за  7 лв.<br> Дава [10], получава ресто [1, 2] и остава с банкноти [1, 1, 1, 1, 2, 2, 50] на обща стойност от 58 лв.</li>
<li>Покупка за  10 лв.<br> Дава [50], получава ресто [20, 20] и остава с банкноти [1, 1, 1, 1, 2, 2, 20, 20] на обща стойност от 48 лв.</li>
<li>Покупка за  17 лв.<br> Дава [20], получава ресто [1, 2] и остава с банкноти [1, 1, 1, 1, 1, 2, 2, 2, 20] на обща стойност от 31 лв.</li>
<li>Покупка за  17 лв.<br> Дава [20], получава ресто [1, 2] и остава с банкноти [1, 1, 1, 1, 1, 1, 2, 2, 2, 2] на обща стойност от 14 лв.</li>
</ol>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2020/week5/MaryPurchases.java" target="_blank">Примерен Java код</a><br>
	</div> 
</div>
</div>
<!-- end of week 5-->
<input type="checkbox" id=week6Toggle>
<label for=week6Toggle class="week">
<h2 id=week6>Седмица №6<span></span></h2>
</label>	
<div>
<h3 id="week6,question1">Приятели и непознати</h3>
<p>В един идеален свят, двама души са или приятели, или непознати, понеже не са имали възможност да се запознаят и да станат приятели.<br> Казваме, че група хора са "пълни приятели", когато всеки (от групата) е приятел с всеки друг от групата.<br> Казваме, че група хора са "напълно непознати", когато никой (от групата) не е приятел с никой от останалите от групата.<br> В нашия минималистичен идеален свят попадат шестима души, избрани по неизвестен за нас начин. Кои от твърденията за тези 6 човека (без участието на други хора) са винаги верни?
<ul class="answersWithCheckbox">
	<li>Винаги можем да намерим трима, които са или пълни приятели, или напълно непознати.</li>
	<li>Ако имаме подгрупа oт четирима пълни приятели, то броят приятелства е по-голям от броя на "непознанствата" (двойките хора, които не се познават).</li>
	<li>Ако имаме подгрупа oт трима напълно непознати, то няма как всеки от шестимата да познава по точно двама души.</li>
	<li>Ако знаем, че всеки двама имат поне по един общ приятел, то задължително има група от четирима пълни приятели.</li>
	<li>Няма как всеки двама души да имат точно по един общ приятел (измежду останалите четирима).</li>
	<li>Няма как всеки двама души да имат точно по един общ непознат (измежду останалите четирима).</li>
</ul>
</p>
<div>
	<input type="checkbox" id=solution61><label class="explanationbutton" for=solution61><span>Обяснение</span></label>
	<div class="explanation">
<h4 id="week6,solution61,ProgramSolution">Решението на програмиста:</h4>
В предвид многото и различни проверки, които се налага да се правят, е удобно да представим групата от 6 човека като граф, като за всеки човек пазим списъка от приятели.<br>
По-интересена е задачата как да генерираме всички възможни графи за приятелствата между тези 6 човека.<br>
В група от \( n \) човека има  \( n*(n-1)/2 \) двойки, т.е. за 6 човека двойките са \( 6*(6-1)/2=15 \).<br>
Тъй като за всяка двойка хора имаме 2 възможности (те се познават и те не се познават), то можем да използваме двоичния запис на числата от 0 до 2<sup>15</sup> като еднозначна дефиниция на всички съществуващи графи. Например:<br>
<ul>
	<li>Числото 0 дефинира граф, в който няма познати.</li>
	<li>Числото 2<sup>15</sup>-1, което има двоично представяне с 15 единици, дефинира граф, в който всеки познава всеки.</li>
	<li>Числото 19999, което има двоично представяне 100111000011111, съответства на граф, в който:
		<ol>
			<li>Човекът с индекс 1 познава всички останали (приятелствата, съответстващи на последните 5 единици от двоичния запис на числото).</li>
			<li>Човекът с индекс 2 не познава никой (освен 1).</li>
			<li>Човекът с индекс 3 познава 4,5,6 (и 1).</li>
			<li>Човекът с индекс 4 не познава никой (освен 1 и 3).</li>
			<li>Човекът с индекс 5 познава 6 (и 1, и 3).</li>
			<li>Човекът с индекс 6 познава (1, 3 и 5).</li>
		</ol>
</ul><br> 
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2020/week6/FriendshipGraph.java" target="_blank">Примерен Java код</a><br>

<h4 id="week6,solution61,MathSolution">Решението на математика:</h4>
<ol>
<li>Нека представим шестимата души като върхове на граф, като връзката между двама души, които са приятели, е синя, а връзката между двама души, които са непознати, е червена.<br>
От всеки връх имаме точно 5 връзки (по една към останалите 5 върха), т.е. или имаме поне 3 сини, или поне 3 червени връзки.<br>
Нека предположим, че имаме поне 3 сини връзки (случаят с поне 3 червени връзки ще бъде аналогичен).<br>
<img src="/technoteaser/docs/images/2020/1O2eXrRY1HUC4AjjH27pMZXsSa6ERCYeBXMa47pkYPQ.png" width="100px" style="margin-right: 10px; padding-right: 10px; display: block; background-color: transparent;">
Разглеждаме трите върха, към които имаме синя връзка  - това са трима човека с общ приятел.
Ако измежду тях има синя връзка (двама, които се познават), то те, заедно с първоначалния връх (общ познат), ще образуват група от трима пълни приятели.
<img src="/technoteaser/docs/images/2020/iRRIhZIlgq_xzmLUsXhhysgooEYy2OTmzbbuBbVvVQE.png" width="100px" style="margin-right: 10px; padding-right: 10px; display: block; background-color: transparent;">
Ако измежду тях няма синя връзка (т.е. всички връзки са червени), то те тримата ще бъдат напълно непознати.
<img src="/technoteaser/docs/images/2020/ynsg_Cc5-irCCW2Cr3GJ4kPPk5nMeZNRaemycZUcruw.png" width="100px" style="margin-right: 10px; padding-right: 10px; display: block; background-color: transparent;"><br>
<font color="darkgreen">✔ Винаги можем да намерим трима, които са или пълни приятели, или напълно непознати.</font><br><br>
Това твърдение е познато като Теорема за приятелите и непознатите (<a href="https://en.wikipedia.org/wiki/Theorem_on_friends_and_strangers" target=_blank>Theorem on friends and strangers</a>).<hr>
</li>
<li> Всеки двама човека в групата са или приятели, или непознати. Затова сборът на приятелствата и "непознанствата" е равен на броя на различните двойки хора, а те са комбинация от 6 елемента (6 души) от клас 2 (във всяка двойка участват двама различни човека измежду шестимата). <br>
\( C_{n}^k = {n \choose k} = \dfrac{n!}{k!(n-k)!} \)<br>
\( C_{6}^2 = \dfrac{6!}{2!*4!} = \dfrac{6*5}{2} = 15\)<br>
Следователно сборът на приятелствата и непознанствата е винаги равен на 15.<br>
Нека предположим, че имаме група от четирима пълни приятели и няма други приятелства. <br>
Четирима пълни приятели изискват 4*3/2=6 приятелства, но ние вече знаем, че остават още 9 двойки хора, които не се познават, т.е. не е вярно, че: <br>
<font color="darkred">✘ Ако имаме група oт четирима пълни приятели, то броят приятелства е по-голям от броя на двойките хора, които не се познават.</font>
<hr>
</li>
<li>
На представения по-долу граф, в който всеки човек е номериран от 1 до 6, a приятелствата са представени като връзки, е показано как може всеки да познава точно двама въпреки групата от трима напълно непознати (1, 2 и 3).  
<img src="/technoteaser/docs/images/2020/EcmvTuyaJEaNLho6BEYcxqYFECc9-7USfMYIzp97C7E.png" width="200px" style="margin-right: 10px; padding-right: 10px; display: block; background-color: transparent;"><br>
Т.е. не е вярно, че: <br>
<font color="darkred">✘ Ако имаме група oт трима напълно непознати, то няма как всеки от шестимата да познава по точно двама души.</font>
<hr>
</li>
<li>
Ако двама човека се познават помежду си и познават всички останали (нека това са 1 и 2), а останалите (3, 4, 5 и 6) не се познават помежду си, тогава всеки двама души ще имат общ приятел. Фактът, че 3, 4, 5 и 6 не се познават, означава, че нямаме група от 4 пълни приятели.<br>
<img src="/technoteaser/docs/images/2020/E_h_YoRqIC8eEEt1_s6IFDQtKyirGmK_jOF96eGWoq0.png" width="250px" style="margin-right: 10px; padding-right: 10px; display: block; background-color: transparent;"><br>
Т.е. не е вярно, че: <br>
<font color="darkred">✘ Ако знаем, че всеки двама имат поне по един общ приятел, то задължително има група от четирима пълни приятели.</font>
<hr>
</li>
<li>
В <a href="https://bg.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BD%D0%B0_%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%82%D0%B5" target=_blank>теорията на графите</a> приятелски граф (<a href="https://en.wikipedia.org/wiki/Friendship_graph" target=_blank>Friendship graph</a>, наричан още Dutch windmill graph или n-fan) е граф с един централен връх, който е свързан с всички останали (периферни) върхове, които на свой ред имат точно една допълнителна (втора) връзка с друг периферен връх. Формата наподобява вятърна мелница или вентилатор. Графите се обозначават като F<sub>n</sub>, където индексът n указва броя на "перките" (цикличните графи C<sub>3</sub>), като на графиката можем да видим съответно графите F<sub>2</sub>, F<sub>3</sub> и F<sub>4</sub>.
<img src="/technoteaser/docs/images/2020/NZo9VMXoOeyKgpAMZijA-xUCnfk2eudFivnAFGnjtr0.png" width="500px" style="margin-right: 10px; padding-right: 10px; display: block; background-color: transparent;"><br>
Съществува и Приятелска теорема, според която краен граф със свойството всеки два върха да имат точно 1 общ съсед, е задължително приятелски граф от вече описания вид. Но приятелските графи имат 5 (за F<sub>2</sub>) или 7 (за F<sub>3</sub>) върха, т.е. не съществува приятелски граф с 6 върха, което означава, че: <br>
<font color="darkgreen">✔ Няма как всеки двама души да имат точно по един общ приятел (измежду останалите четирима).</font><hr> 
</li>
<li>Ако няма как всеки двама души да имат точно по един общ приятел (измежду останалите четирима), то трябва да е вярно и огледалното твърдение, т.е.: <br>
<font color="darkgreen">✔ Няма как всеки двама души да имат точно по един общ непознат (измежду останалите четирима).</font>
</li>
</ol>
	</div>
</div>
<h3 id="week6,question2">Изчислителна мощ</h3>
<p>Търсим естествени числа \(n\) със следните свойства:
<ol>
	<li>Сумата от точните делители на \(n\) (вкл. 1, но без самото число \(n\)) да е по-голяма от \(n\);</li>
	<li>Не съществува подмножество от точни делители на \(n\), чиято сума е равна на \(n\).</li>
</ol>
Примери:<br>
Числото 20 има делители (1, 2, 4, 5, 10), като \(1+2+4+5+10=22 \gt 20\), но понеже \(1+4+5+10=20\), то не отговаря на второто условие.<br>
Първото (най-малкото) естествено число, което отговаря на условията, е 70, с делители (1, 2, 5, 7, 10, 14, 35), като \(1+2+5+7+10+14+35=74 \gt 70 \).<br>
Кое е 15000-то по ред такова число?</p>
<div>
	<input type="checkbox" id=solution62><label class="explanationbutton" for=solution62><span>Обяснение</span></label>
	<div class="explanation">
Числата, отговарящи на тези условия, се наричат странни (<a href="https://en.wikipedia.org/wiki/Weird_number" target=_blank>Weird numbers</a>).<br>
Първата задача, която трябва да решим, е намирането на всички (не непременно прости) делители за всяко число.<br>
Въпреки че не търсим прости числа, можем да използваме модификация на <a href="https://bg.wikipedia.org/wiki/%D0%A0%D0%B5%D1%88%D0%B5%D1%82%D0%BE_%D0%BD%D0%B0_%D0%95%D1%80%D0%B0%D1%82%D0%BE%D1%81%D1%82%D0%B5%D0%BD" target=_blank>Решето на Ератостен</a>, пригодена за делители:<br>
<ul>
	<li>Започваме с числото 2. То очевидно е просто и затова няма как да е странно. Важното обаче е, че следващото число, което ще се дели на 2, е \(2+2=4\). Знаейки това, можем да запишем в подходяща структура от данни, че числото 4 има делител 2.</li>
	<li>Следващото число е 3 и тъй като за него нямаме текущи делители, то също е просто. Затова повтаряме процедурата и за него - запазваме информацията, че числото  \(3+3=6\) е следващото число, което се дели на 3, и продължаваме със следващото число.</li>
	<li>За числото 4 вече знаем, че се дели на 2, затова трябва да проверим дали не е странно. Тъй като делителите му са (1,2), а \(1+2=3\lt4\), то не отговаря на условията. Тъй като то се дели на 2, трябва да преценим, че следващото число, което се дели на 2, е \(4+2=6\) (информация, която трябва да запазим), а следващото число, което се дели на 4, е \(4+4=8\). </li>
	<li>Така продължаваме със следващите числа, като получаваме алгоритъм за "пълзящо" решето на Ератостен, което ни предоставя делителите на всяко следващо число.</li>
</ul>
Можем да забележим, че делителите за всяко число получаваме сортирани по големина (дори и със структура от данни списък), като най-големият делител е бил добавен пръв, понеже него сме срещнали най-назад в процеса на обхождане на числата.<br>
Следващата стъпка е да намерим ефективен алгоритъм за проверка на второто (по-сложно) условие за странни числа - съществува ли подмножество от делители, чиято сума е равна точно на числото.<br>Тъй като множество от \(N\) елемента има \(2^N\) подмножества, дори и да премахнем очевидно неработещите за нас (като например празното подмножество, тези с по един елемент и това с всички елементи), проверката на всички останали би била отново алгоритъм с експоненциална сложност.<br>
Затова ще се фокусираме върху това как да намалим броя на множителите, с които работим. Можем да забележим, че най-големият делител често се налага да присъства задължително в евентуалната сума. Ако ползваме примера от условието за делителите на числото 70, които са (1, 2, 5, 7, 10, 14, 35), виждаме, че \(1+2+5+7+10+14=39\lt70\). Т.е. ако има сума на делители, която да е равна на 70, то тя задължително трябва да включва най-големия делител 35 и вместо да търсим точна сума 70 измежду числата (1, 2, 5, 7, 10, 14, 35), можем да търсим точна сума 35 измежду числата (1, 2, 5, 7, 10, 14). Повтаряйки оптимизацията още няколко пъти, получаваме последователно търсене на сума 21 измежду (1, 2, 5, 7, 10), търсене на сума 11 измежду (1, 2, 5, 7), търсене на сума 4 измежду (1, 2, 5). Тук забелязваме, че числото 5 можем да премахнем като твърде голямо, което по същество е втори вид оптимизация, а понеже със сумата на числата 1 и 2 не можем да достигнем до 4, виждаме, че не съществува подмножество, т.е. числото е странно. Получаваме следния алгоритъм:
<ul>
	<li>Изполваме най-големия делител, когато е ясно, че той трябва да бъде част от евентуално съществуваща сума, равна на числото;</li>
	<li>Премахваме най-големия делител, когато е по-голям от числото;</li>
	<li>Когато по-горните оптимизации са вече неприложими и не сме достигнали до ясен отговор дали съществува точна сума, или не, продължаваме със стандартен рекурсивен алгоритъм, който проверява сумите на всички възможни събмножества на делителите.</li>
</ul><br> 
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2020/week6/WeirdNumberGenerator.java" target="_blank">Примерен Java код</a><br>
<b>Отговор: 9656636</b>
<hr>
<a href="http://oeis.org/A006037" target=_blank>Страница за странните числа</a> има в <a href="http://oeis.org/" target=_blank>онлайн енциклопедията за числови редици (OEIS®)</a>, като там може да бъде намерен и <a href="http://oeis.org/A006037/b006037.txt" target=_blank>списъкът на първите 10000 странни числа</a>.
	</div>
</div>
<h3 id="week6,question3">Машина за думи</h3>
<p>Машина за думи поддържа следните операции:
<ul>
	<li><b>Покупка на буква</b> - чрез тази операция добавяме буква накрая (като последна) на текущата дума, като:
		<ul>
			<li> Буквата <font color="darkred">А</font> струва 1 лв.</li>
			<li> Буквата <font color="darkred">Б</font> струва 2 лв.</li>
			<li> Буквата <font color="darkred">В</font> струва 3 лв.</li>
			<li style="list-style-type: none;"> ... </li>
			<li> Буквата <font color="darkred">Я</font> струва 30 лв.</li>
		</ul>
		Това е единствената операция, която можем да ползваме в началото, тъй като машината стартира работа с празната дума.<br> 
		Примери: '' → '<font color="darkred"><u>С</u></font>' (18 лв.),  '<font color="darkred">СА</font>' → '<font color="darkred">СА<u>П</u></font>' (16 лв.)
	</li>
	<li><b>Инкрементиране</b> - замяна на всяка една буква в текущата дума със следващата по азбучен ред.<br>
	    Операцията има фиксирана цена от 2 лв. и не може да се ползва, ако в текущата дума присъства буквата <font color="darkred">Я</font>.<br>
		Примери: '<font color="darkred">С</font>' → '<font color="darkred"><u>Т</u></font>' (2 лв.), '<font color="darkred">САП</font>' → '<font color="darkred"><u>ТБР</u></font>' (2 лв.)
	</li>
	<li><b>Размяна</b> на местата на две съседни букви на фиксирана цена от 1 лв.<br>
		Операцията не може да се прилага върху думи с по-малко oт 2 букви.<br>
		Пример: '<font color="darkred">САП</font>' → '<font color="darkred">С<u>ПА</u></font>' (1 лв.)
	</li>
</ul>
Каква е най-малката сума пари (в лв.), с която можем да конструираме думата '<font color="darkred">САПТЕХНОБЛЪСКАНИЦА</font>', използвайки машината?
</p>
<div>
	<input type="checkbox" id=solution63><label class="explanationbutton" for=solution63><span>Обяснение</span></label>
	<div class="explanation">
Можем да разглеждаме всяка конкретна текуща дума и възможните следващи думи, до които можем да достигнем чрез някоя от операциите, като граф. На пръв поглед структурата прилича на дърво с връх празната дума, с която стартираме, но понеже до повечето думи можем да достигнем по повече от един начин, структурата е <a href="https://bg.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BE%D1%82_%D0%B4%D0%B0%D0%BD%D0%BD%D0%B8)#%D0%92%D0%B8%D0%B4%D0%BE%D0%B2%D0%B5_%D0%B3%D1%80%D0%B0%D1%84%D0%B8" target=_blank>ориентиран, претеглен, цикличен, безкраен граф</a>. Прави впечатление, че на всяка стъпка имаме твърде много възможности (разклонения), които трудно можем да оценим като част от потенциални решения или не. Задачата, обаче, значително се улеснява, ако я решим в обратен ред, т.е. започнем от думата '<font color="darkred">САПТЕХНОБЛЪСКАНИЦА</font>' и целим да достигнем празната дума, като за целта ползваме "огледални" операции, а именно:
<ul>
	<li><b>Премахване</b> на последната буква от текущата дума на цената, на която бихме я добавили.</li>
	<li><b>Декрементиране</b> на текущата дума на същата фиксирана цена от 2 лв., каквато имаме за операцията инкрементиране, като операцията е невъзможна, когато в думата присъства буквата <font color="darkred">А</font>.</li>
	<li><b>Размяна</b> на местата на две съседни букви (тази операция съвпада с огледалния си образ) на стойност от 1 лв.</li>
</ul>
Трябва да съобразим, че:
<ul>
	<li>Операцията <b>премахване</b> можем да прилагаме всеки път. Това е и единствената операция, която ни доближава до крайната цел (празната дума), като с другите две операции можем само да влияем на крайната цена.</li>
	<li>Oперацията <b>декрементиране</b> не е оптимална за текущи думи, които се състоят от една буква, защото тази буква можем да премахнем директно и това ще изисква по-ниска цена. Когато текущата дума се състои от две букви, декрементирането ще ни спести 2 лв от бъдещите операции по премахване на буквите, но и самата операция струва 2 лв., така че отново не печелим нищо. За думи с 3 или повече букви декрементирането винаги, когато е възможно, е най-оптималната операция.</li>
	<li><b>Размяна</b> на съседни букви ни доближава до целта по оптимален откъм цена начин само и единствено когато преместваме последната буква <font color="darkred">А</font> надясно. Защо това е така?<br> Ако буквата <font color="darkred">А</font> не присъства в думата, както вече знаем, най-оптималната операция е или декрементирането, или премахването на букви.<br>Нека разгледаме текуща дума, която има буквата <font color="darkred">А</font> някъде по средата (<font color="darkred">...А...</font>). В такава ситуация не можем да ползваме операцията декрементиране, докато не се отървем от това <font color="darkred">А</font>, за което пък е нужно буквата да бъде последна, т.е. имаме две възможности:
		<ul>
			<li>Да преместваме <font color="darkred">А</font> надясно, докато не стане последна буква;</li>
			<li>Да премахваме последните букви, докато <font color="darkred">А</font> отново стане последна буква.</li>
		</ul>
		И в двата сценария размяната на други съседни букви само би увеличила крайната цена или в най-добрия случай би била подходяща операция, която можем да отложим за по-нататък, с което не променяме логиката на алгоритъма за оптимална крайна цена.<br>
	 </li>
	</ul>

	С тези ограничения (форма на <a href="https://bg.wikipedia.org/wiki/%D0%95%D0%B2%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0" target=_blank>евристика</a>), които премахват доста голяма част от разклоненията в дървото от възможности, фокусирайки се само върху оптималните пътища, можем да използваме алгоритъма <a href="https://bg.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D1%8A%D0%BC_%D0%90*" target=_blank>A* (A-звезда)</a>, при който:
	<ul>

	<li>В подходяща структура от данни, наричана фронт и обикновено реализирана чрез <a href="https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html" target=_blank>приоритетна опашка (Priority Queue)</a>, пазим всички временни думи, до които сме достигнали, заедно с тяхната текуща цена. Първоначално инициализираме структурата с думата <font color="darkred">САПТЕХНОБЛЪСКАНИЦА</font> с текуща цена 0 лв.
	</li>
	<li>Всеки път вземаме (и премахваме) дума от фронта с най-малка цена, като за тази дума изпълняваме следните операции:</li>
		<ul>
			<li>Aкo буквата <font color="darkred">А</font> не присъства в думата и думата има повече от 2 букви, прилагаме операция декрементиране, като новополучената дума, заедно с новата цена, запазваме във фронта. Тъй като това е най-оптималната откъм цена операция, други операции в този случай не разглеждаме.</li>
			<li>Ако декрементиране не е било възможно:</li> 
				<ul>
					<li>Премахваме последната буква и новополучената дума, заедно с новополучената цена, запазваме в структурата.</li>
					<li>Ако буквата <font color="darkred">А</font> присъства в думата, преместваме последното (ако са повече) срещане на <font color="darkred">А</font> като последна буква на думата (чрез последователност от размени) и я премахваме, като новополучената дума, заедно с новополучената цена, запазваме във фронта.</li>
				</ul>
		</ul>
		<li>Всеки път, когато достигаме до празната дума с нова, по-малка цена, запазваме този резултат като текущо най-добър.</li>
		<li>Алгоритъмът продължава работа, докато вземем от фронта дума с по-голяма цена от текущото най-добро решение (ако има такова) или докато изчерпаме думите във фронта.</li>
	</ul>
    <b>Имплементационни детайли:</b><br>
    <a href="https://bg.wikipedia.org/wiki/%D0%91%D1%8A%D0%BB%D0%B3%D0%B0%D1%80%D1%81%D0%BA%D0%B0_%D0%B0%D0%B7%D0%B1%D1%83%D0%BA%D0%B0" target=_blank>Българската азбука</a> е разположена почти последователно в <a href="https://bg.wikipedia.org/wiki/%D0%A3%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4#%D0%A3%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4_%D0%B3%D1%80%D1%83%D0%BF%D0%B8_%D0%B8_%D0%B1%D0%BB%D0%BE%D0%BA%D0%BE%D0%B2%D0%B5" target=_blank>Unicode таблицата</a> изцяло в основната група (Basic Multilingual Plane), т.е. всяка буква, когато е част от символен низ (String), е представена с единствена символна стойност (char). Забелязваме обаче, че кодът на буквата <font color="darkred">А</font> е 1040, докато кодът на буквата <font color="darkred">Я</font> е 1071 (вместо очакваното 1069). Разликата се дължи на буквата <font color="darkred">Ы</font> с код 1067 между буквите <font color="darkred">Ъ</font> (1066) и <font color="darkred">Ь</font> (1068), както и на буквата <font color="darkred">Э</font> (1069) между буквите <font color="darkred">Ь</font> (1068) и <font color="darkred">Ю</font> (1070). Тъй като най-голямата буква (като код) от текущата дума е <font color="darkred">Ъ</font> (1066), т.е. преди вмъкнатите букви, можем да изчисляваме цената на всяка буква (на Java) като <code>(int) letter - (int) 'A' + 1</code>, но за да бъде решението чисто откъм имплементация, е за предпочитане да дефинираме наша собствена структура от данни за азбуката, като например ползваме <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target=_blank>изброен тип</a>.<br><br>
<a href="https://github.com/saplabsbg/technoteaser/blob/master/src/saptechnoteaser2020/week6/WordMachine.java" target="_blank">Примерен Java код</a><br><br>
Примерно конструиране на думата САПТЕХНОБЛЪСКАНИЦА за 125 лв.
<div style="background: #000;border: 1px solid #ccc; color: white; display: block;padding: 5px; width: 100%; font-size: 80%; overflow-x: scroll; white-space: nowrap;">
+1 [] -> [А] (Купуваме буквата А)<br>
+2 [А] -> [А, Б] (Купуваме буквата Б)<br>
+5 [А, Б] -> [А, Б, Д] (Купуваме буквата Д)<br>
+10 [А, Б, Д] -> [А, Б, Д, Й] (Купуваме буквата Й)<br>
+1 [А, Б, Д, Й] -> [А, Б, Д, Й, А] (Купуваме буквата А)<br>
+4 [А, Б, Д, Й, А] -> [В, Г, Ж, Л, В] (Инкрементираме 2 пъти)<br>
+5 [В, Г, Ж, Л, В] -> [В, А, Г, Ж, Л, В] (Купуваме буквата А и я разменяме с лявостоящата буква 4 пъти)<br>
+2 [В, А, Г, Ж, Л, В] -> [Г, Б, Д, З, М, Г] (Инкрементираме 1 път)<br>
+3 [Г, Б, Д, З, М, Г] -> [Г, Б, Д, З, А, М, Г] (Купуваме буквата А и я разменяме с лявостоящата буква 2 пъти)<br>
+2 [Г, Б, Д, З, А, М, Г] -> [Д, В, Е, И, Б, Н, Д] (Инкрементираме 1 път)<br>
+4 [Д, В, Е, И, Б, Н, Д] -> [Д, В, Е, И, А, Б, Н, Д] (Купуваме буквата А и я разменяме с лявостоящата буква 3 пъти)<br>
+1 [Д, В, Е, И, А, Б, Н, Д] -> [Д, В, Е, И, А, Б, Н, Д, А] (Купуваме буквата А)<br>
+10 [Д, В, Е, И, А, Б, Н, Д, А] -> [Д, В, Е, И, А, Б, Н, Д, А, Й] (Купуваме буквата Й)<br>
+4 [Д, В, Е, И, А, Б, Н, Д, А, Й] -> [Ж, Д, З, К, В, Г, П, Ж, В, Л] (Инкрементираме 2 пъти)<br>
+5 [Ж, Д, З, К, В, Г, П, Ж, В, Л] -> [Ж, Д, З, К, В, Г, А, П, Ж, В, Л] (Купуваме буквата А и я разменяме с лявостоящата буква 4 пъти)<br>
+2 [Ж, Д, З, К, В, Г, А, П, Ж, В, Л] -> [З, Е, И, Л, Г, Д, Б, Р, З, Г, М] (Инкрементираме 1 път)<br>
+3 [З, Е, И, Л, Г, Д, Б, Р, З, Г, М] -> [З, Е, И, Л, Г, Д, Б, Р, З, А, Г, М] (Купуваме буквата А и я разменяме с лявостоящата буква 2 пъти)<br>
+4 [З, Е, И, Л, Г, Д, Б, Р, З, А, Г, М] -> [Й, З, К, Н, Е, Ж, Г, Т, Й, В, Е, О] (Инкрементираме 2 пъти)<br>
+2 [Й, З, К, Н, Е, Ж, Г, Т, Й, В, Е, О] -> [Й, З, К, Н, Е, Ж, Г, Т, Й, В, Е, А, О] (Купуваме буквата А и я разменяме с лявостоящата буква 1 път)<br>
+6 [Й, З, К, Н, Е, Ж, Г, Т, Й, В, Е, А, О] -> [М, К, Н, Р, И, Й, Ж, Х, М, Е, И, Г, С] (Инкрементираме 3 пъти)<br>
+11 [М, К, Н, Р, И, Й, Ж, Х, М, Е, И, Г, С] -> [М, К, Н, А, Р, И, Й, Ж, Х, М, Е, И, Г, С] (Купуваме буквата А и я разменяме с лявостоящата буква 10 пъти)<br>
+8 [М, К, Н, А, Р, И, Й, Ж, Х, М, Е, И, Г, С] -> [Р, О, С, Д, Ф, М, Н, К, Щ, Р, Й, М, З, Х] (Инкрементираме 4 пъти)<br>
+8 [Р, О, С, Д, Ф, М, Н, К, Щ, Р, Й, М, З, Х] -> [Р, О, С, Д, Ф, М, Н, А, К, Щ, Р, Й, М, З, Х] (Купуваме буквата А и я разменяме с лявостоящата буква 7 пъти)<br>
+2 [Р, О, С, Д, Ф, М, Н, А, К, Щ, Р, Й, М, З, Х] -> [С, П, Т, Е, Х, Н, О, Б, Л, Ъ, С, К, Н, И, Ц] (Инкрементираме 1 път)<br>
+15 [С, П, Т, Е, Х, Н, О, Б, Л, Ъ, С, К, Н, И, Ц] -> [С, А, П, Т, Е, Х, Н, О, Б, Л, Ъ, С, К, Н, И, Ц] (Купуваме буквата А и я разменяме с лявостоящата буква 14 пъти)<br>
+4 [С, А, П, Т, Е, Х, Н, О, Б, Л, Ъ, С, К, Н, И, Ц] -> [С, А, П, Т, Е, Х, Н, О, Б, Л, Ъ, С, К, А, Н, И, Ц] (Купуваме буквата А и я разменяме с лявостоящата буква 3 пъти)<br>
+1 [С, А, П, Т, Е, Х, Н, О, Б, Л, Ъ, С, К, А, Н, И, Ц] -> [С, А, П, Т, Е, Х, Н, О, Б, Л, Ъ, С, К, А, Н, И, Ц, А] (Купуваме буквата А)
</div>
Решението е валидно за конкретните цени на операциите и при други цени би претърпяло промени в избора на оптимални, възможни и отложени операции.<br>
Допълнителни оптимизации за едно по-общо решение също са възможни. Например, преди да добавим нова дума във фронта, можем да проверяваме дали тя не е вече там (или не е била там), като оставяме само думата и операциите за нейното създаване, даващи по-ниска сумарна цена.
	</div>
</div>
</div>
<!-- end of week 6-->
<script>
function hashChange() {
	if (window.location.hash) {
		var hashID = window.location.hash.substr(1);
        var hashArr = hashID.split(",");
        for (i in hashArr) {
			var obj = document.getElementById(hashArr[i] + (i==0 ? "Toggle" : ""));
			if (obj) {obj.checked = true;}
		}
	}
}
window.onhashchange = hashChange;
window.onload = hashChange;
hashChange();
</script>
<br>
<div class="footer">
<a href="https://www.sap.com/about/careers/who-we-are/locations/sap-labs-bulgaria.html" target="_blank"><p class="footer-element">Виж повече за развойния център на SAP в София</p></a><a href="https://www.sap.com/about/careers/who-we-are/locations/sap-labs-bulgaria.html" target="_blank"><img class="footer-image" src="/technoteaser/docs/images/sap_logo.png" width="40" height="20"></a> <a href="https://www.facebook.com/saplabsbg" target="_blank"><p class="footer-element">Харесай страницата ни във Facebook</p></a><a href="https://www.facebook.com/saplabsbg" target="_blank"><img class="footer-image" src="/technoteaser/docs/images/fb_logo.png" width="30" height="20"></a> <a href="https://jobs.sap.com/search/?q=&locationsearch=bulgaria" target="_blank"><p class="footer-element">Разгледай отворените позиции при нас</p></a><a href="https://jobs.sap.com/search/?q=&locationsearch=bulgaria" target="_blank"><img class="footer-image" src="/technoteaser/docs/images/network.png" width="25" height="25"></a>
</div>

{:/}
